<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="theme-color" content="#ea580c" id="theme-color-meta">
<meta name="description" content="HSK flash cards with spaced repetition for learning Chinese.">
<link rel="manifest" href="./manifest.webmanifest">
<link rel="icon" href="./icons/icon.svg" type="image/svg+xml">
<link rel="apple-touch-icon" href="./icons/apple-touch-icon-180.png">
<title>Chinese Flash Cards — Four Decks</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --bg-page: #f0f2f5;
  --bg-card: #fff;
  --bg-card-hover: rgba(0, 0, 0, 0.08);
  --text-primary: #333;
  --text-secondary: #555;
  --text-muted: #888;
  --text-subtle: #999;
  --text-hint: #bbb;
  --pill-bg: #fff7ed;
  --pill-border: #fed7aa;
  --pill-text: #9a3412;
  --pill-hover-bg: #ffedd5;
  --pill-hover-border: #ea580c;
  --accent: #ea580c;
  --accent-muted: #9a3412;
  --tidbit-bg: #fef9ef;
  --tidbit-border: #ea580c;
  --cultural-text: #3f3f46;
  --cultural-source: #78716c;
  --cultural-translation: #57534e;
  --correct-bg: #dcfce7;
  --correct-border: #16a34a;
  --correct-text: #166534;
  --wrong-bg: #fee2e2;
  --wrong-border: #dc2626;
  --wrong-text: #991b1b;
  --neutral-border: #ddd;
  --neutral-bg: #f5f5f5;
  --neutral-bg-hover: #e5e5e5;
  --neutral-text: #737373;
  --neutral-text-hover: #525252;
  --reset-border: #ccc;
  --reset-text: #999;
  --reset-hover-border: #999;
  --reset-hover-text: #666;
  --shadow: 0 4px 24px rgba(0, 0, 0, 0.08);
  --shadow-hover: 0 6px 32px rgba(0, 0, 0, 0.12);
}

/* Manual theme override (when user toggles) */
html[data-theme="light"] {
  --bg-page: #f0f2f5;
  --bg-card: #fff;
  --bg-card-hover: rgba(0, 0, 0, 0.08);
  --text-primary: #333;
  --text-secondary: #555;
  --text-muted: #888;
  --text-subtle: #999;
  --text-hint: #bbb;
  --pill-bg: #fff7ed;
  --pill-border: #fed7aa;
  --pill-text: #9a3412;
  --pill-hover-bg: #ffedd5;
  --pill-hover-border: #ea580c;
  --accent: #ea580c;
  --accent-muted: #9a3412;
  --tidbit-bg: #fef9ef;
  --tidbit-border: #ea580c;
  --cultural-text: #3f3f46;
  --cultural-source: #78716c;
  --cultural-translation: #57534e;
  --correct-bg: #dcfce7;
  --correct-border: #16a34a;
  --correct-text: #166534;
  --wrong-bg: #fee2e2;
  --wrong-border: #dc2626;
  --wrong-text: #991b1b;
  --neutral-border: #ddd;
  --neutral-bg: #f5f5f5;
  --neutral-bg-hover: #e5e5e5;
  --neutral-text: #737373;
  --neutral-text-hover: #525252;
  --reset-border: #ccc;
  --reset-text: #999;
  --reset-hover-border: #999;
  --reset-hover-text: #666;
  --shadow: 0 4px 24px rgba(0, 0, 0, 0.08);
  --shadow-hover: 0 6px 32px rgba(0, 0, 0, 0.12);
}

html[data-theme="dark"] {
  --bg-page: #1a1a1a;
  --bg-card: #2d2d2d;
  --bg-card-hover: rgba(255, 255, 255, 0.06);
  --text-primary: #e4e4e7;
  --text-secondary: #a1a1aa;
  --text-muted: #71717a;
  --text-subtle: #52525b;
  --text-hint: #3f3f46;
  --pill-bg: #422006;
  --pill-border: #78350f;
  --pill-text: #fdba74;
  --pill-hover-bg: #451a03;
  --pill-hover-border: #ea580c;
  --accent: #f97316;
  --accent-muted: #fdba74;
  --tidbit-bg: #292524;
  --tidbit-border: #ea580c;
  --cultural-text: #d6d3d1;
  --cultural-source: #a8a29e;
  --cultural-translation: #78716c;
  --correct-bg: #14532d;
  --correct-border: #22c55e;
  --correct-text: #86efac;
  --wrong-bg: #450a0a;
  --wrong-border: #ef4444;
  --wrong-text: #fca5a5;
  --neutral-border: #3f3f46;
  --neutral-bg: #27272a;
  --neutral-bg-hover: #3f3f46;
  --neutral-text: #a1a1aa;
  --neutral-text-hover: #d4d4d8;
  --reset-border: #52525b;
  --reset-text: #71717a;
  --reset-hover-border: #a1a1aa;
  --reset-hover-text: #d4d4d8;
  --shadow: 0 4px 24px rgba(0, 0, 0, 0.4);
  --shadow-hover: 0 6px 32px rgba(0, 0, 0, 0.5);
}

@media (prefers-color-scheme: dark) {
  :root:not([data-theme]) {
    --bg-page: #1a1a1a;
    --bg-card: #2d2d2d;
    --bg-card-hover: rgba(255, 255, 255, 0.06);
    --text-primary: #e4e4e7;
    --text-secondary: #a1a1aa;
    --text-muted: #71717a;
    --text-subtle: #52525b;
    --text-hint: #3f3f46;
    --pill-bg: #422006;
    --pill-border: #78350f;
    --pill-text: #fdba74;
    --pill-hover-bg: #451a03;
    --pill-hover-border: #ea580c;
    --accent: #f97316;
    --accent-muted: #fdba74;
    --tidbit-bg: #292524;
    --tidbit-border: #ea580c;
    --cultural-text: #d6d3d1;
    --cultural-source: #a8a29e;
    --cultural-translation: #78716c;
    --correct-bg: #14532d;
    --correct-border: #22c55e;
    --correct-text: #86efac;
    --wrong-bg: #450a0a;
    --wrong-border: #ef4444;
    --wrong-text: #fca5a5;
    --neutral-border: #3f3f46;
    --neutral-bg: #27272a;
    --neutral-bg-hover: #3f3f46;
    --neutral-text: #a1a1aa;
    --neutral-text-hover: #d4d4d8;
    --reset-border: #52525b;
    --reset-text: #71717a;
    --reset-hover-border: #a1a1aa;
    --reset-hover-text: #d4d4d8;
    --shadow: 0 4px 24px rgba(0, 0, 0, 0.4);
    --shadow-hover: 0 6px 32px rgba(0, 0, 0, 0.5);
  }
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  background: var(--bg-page);
  min-height: 100vh;
  min-height: 100dvh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: max(16px, env(safe-area-inset-top)) max(16px, env(safe-area-inset-right)) max(16px, env(safe-area-inset-bottom)) max(16px, env(safe-area-inset-left));
  color: var(--text-primary);
  overscroll-behavior-y: none;
  -webkit-tap-highlight-color: transparent;
}

header {
  text-align: center;
  margin-bottom: 24px;
  width: 100%;
  max-width: 420px;
}

header h1 {
  font-size: 1.4rem;
  font-weight: 600;
  color: var(--text-secondary);
}

.progress {
  font-size: 0.9rem;
  color: var(--text-muted);
  margin-top: 6px;
}

.card {
  background: var(--bg-card);
  border-radius: 16px;
  box-shadow: var(--shadow);
  padding: clamp(28px, 6vw, 48px) clamp(20px, 6vw, 40px);
  width: 100%;
  max-width: 420px;
  text-align: center;
  cursor: pointer;
  user-select: none;
  min-height: clamp(260px, 56vh, 420px);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  transition: box-shadow 0.2s;
  touch-action: manipulation;
}

.card:hover {
  box-shadow: var(--shadow-hover);
}

.hanzi {
  font-size: 72px;
  font-weight: 700;
  line-height: 1.2;
  margin-bottom: 12px;
}

.radical-side-glyph {
  display: inline-block;
  transform: translateX(var(--side-shift, 0));
}

.pinyin {
  font-size: 1.4rem;
  color: var(--text-muted);
  margin-bottom: 8px;
}

.radical-side-note {
  font-size: 0.82rem;
  color: var(--text-muted);
  margin-bottom: 8px;
}

.english {
  font-size: 1.2rem;
  color: var(--text-subtle);
  margin-bottom: 8px;
}

.mnemonic {
  font-size: 0.85rem;
  color: var(--text-muted);
  font-style: italic;
  margin-top: 10px;
  margin-bottom: 16px;
  line-height: 1.5;
  max-width: 340px;
}

.hint {
  font-size: 0.8rem;
  color: var(--text-hint);
  margin-top: 12px;
}

.related-radicals {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  justify-content: center;
  margin-top: 12px;
}

.chip-link {
  text-decoration: none;
  border: 1px solid var(--pill-border);
  color: var(--pill-text);
  background: var(--pill-bg);
  border-radius: 999px;
  padding: 4px 10px;
  font-size: 0.8rem;
}

.cultural-tidbit {
  width: 100%;
  margin-top: 14px;
  border-left: 4px solid var(--tidbit-border);
  background: var(--tidbit-bg);
  border-radius: 10px;
  padding: 10px 12px;
  text-align: left;
}

.cultural-quote {
  font-size: 1.1rem;
  line-height: 1.45;
  color: var(--cultural-text);
}

.cultural-source {
  margin-top: 8px;
  font-size: 0.78rem;
  color: var(--cultural-source);
}

.cultural-translation {
  margin-top: 8px;
  font-size: 0.88rem;
  line-height: 1.45;
  color: var(--cultural-translation);
}

.cultural-source a {
  color: var(--accent-muted);
}

.study-page {
  background: var(--bg-card);
  border-radius: 16px;
  box-shadow: var(--shadow);
  padding: 20px;
  width: 100%;
  max-width: 420px;
}

.study-page h2 {
  font-size: 1.3rem;
  color: var(--text-secondary);
  margin-bottom: 10px;
}

.study-page p {
  color: var(--text-muted);
  font-size: 0.95rem;
  line-height: 1.5;
}

.deck-back-link {
  margin-top: 16px;
  font-size: 0.78rem;
  color: var(--text-subtle);
  text-align: center;
}

.deck-back-link a {
  color: var(--text-subtle);
  text-decoration: none;
}

.deck-back-link a:hover {
  color: var(--text-muted);
  text-decoration: underline;
}


.speaker-btn {
  background: none;
  border: 1px solid var(--neutral-border);
  border-radius: 50%;
  width: 44px;
  height: 44px;
  font-size: 1.2rem;
  cursor: pointer;
  color: var(--text-muted);
  display: flex;
  align-items: center;
  justify-content: center;
  margin-top: 8px;
  transition: background 0.15s, color 0.15s;
}

.speaker-btn:hover {
  background: var(--neutral-bg);
  color: var(--text-secondary);
}

.quiz-options {
  display: flex;
  flex-direction: column;
  gap: 10px;
  width: 100%;
  max-width: 320px;
  margin-top: 20px;
}

.quiz-option {
  padding: 14px 18px;
  font-size: 1rem;
  border: 1px solid var(--pill-border);
  border-radius: 999px;
  background: var(--pill-bg);
  color: var(--pill-text);
  cursor: pointer;
  text-align: left;
  transition: border-color 0.15s, background 0.15s;
}

.quiz-option:hover {
  border-color: var(--pill-hover-border);
  background: var(--pill-hover-bg);
}

.quiz-option.correct {
  border-color: var(--correct-border);
  background: var(--correct-bg);
  color: var(--correct-text);
}

.quiz-option.wrong {
  border-color: var(--wrong-border);
  background: var(--wrong-bg);
  color: var(--wrong-text);
}

.quiz-option.reveal-correct {
  border-color: var(--correct-border);
  background: var(--correct-bg);
  color: var(--correct-text);
}

.quiz-btn {
  font-weight: 600;
  border: 1px solid var(--pill-border);
  border-radius: 999px;
  background: var(--pill-bg);
  color: var(--pill-text);
}

.quiz-btn:hover {
  border-color: var(--pill-hover-border);
  background: var(--pill-hover-bg);
  color: var(--pill-text);
}

.quiz-idk-btn {
  margin-top: 12px;
  padding: 10px 16px;
  font-size: 0.9rem;
  border: 1px solid var(--neutral-border);
  border-radius: 999px;
  background: var(--neutral-bg);
  color: var(--neutral-text);
  cursor: pointer;
  transition: border-color 0.15s, background 0.15s;
}

.quiz-idk-btn:hover {
  border-color: var(--reset-hover-border);
  background: var(--neutral-bg-hover);
  color: var(--neutral-text-hover);
}

.quiz-idk-btn:disabled {
  opacity: 0.6;
  cursor: default;
}

.reset-card-btn {
  margin-top: 12px;
}

.done {
  font-size: 1.3rem;
  color: var(--text-muted);
  text-align: center;
  padding: 40px;
}

.done .emoji {
  font-size: 3rem;
  margin-bottom: 16px;
}

footer {
  margin-top: 24px;
  width: 100%;
  max-width: 420px;
  display: flex;
  justify-content: center;
}

.reset-btn {
  background: none;
  border: 1px solid var(--reset-border);
  border-radius: 6px;
  padding: 6px 14px;
  font-size: 0.8rem;
  color: var(--reset-text);
  cursor: pointer;
}

.reset-btn:hover { border-color: var(--reset-hover-border); color: var(--reset-hover-text); }

.sentence-hanzi {
  font-size: 32px;
  font-weight: 700;
  line-height: 1.5;
  margin-bottom: 12px;
  letter-spacing: 2px;
}

.sentence-pinyin {
  font-size: 1.1rem;
  color: var(--text-muted);
  margin-bottom: 8px;
  line-height: 1.5;
}

.sentence-english {
  font-size: 1.1rem;
  color: var(--text-subtle);
  margin-bottom: 8px;
  line-height: 1.5;
}

.word-gloss-chips {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  justify-content: center;
  margin-top: 12px;
}

.word-gloss-chip {
  text-decoration: none;
  border: 1px solid var(--pill-border);
  color: var(--pill-text);
  background: var(--pill-bg);
  border-radius: 999px;
  padding: 4px 10px;
  font-size: 0.8rem;
  display: inline-flex;
  gap: 4px;
  align-items: baseline;
}

.word-gloss-chip .chip-hanzi {
  font-size: 0.95rem;
}

.theme-toggle {
  position: fixed;
  bottom: max(12px, env(safe-area-inset-bottom));
  left: max(12px, env(safe-area-inset-left));
  width: 36px;
  height: 36px;
  padding: 0;
  border: none;
  border-radius: 8px;
  background: transparent;
  color: var(--text-muted);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0.7;
  transition: opacity 0.15s, color 0.15s;
  z-index: 100;
}

.theme-toggle:hover {
  opacity: 1;
  color: var(--text-secondary);
}

.theme-toggle svg {
  width: 20px;
  height: 20px;
}

@media (max-width: 480px) {
  body { justify-content: flex-start; }
  header { margin-bottom: 14px; }
  .card { min-height: clamp(240px, 54dvh, 380px); }
  .hanzi { font-size: clamp(52px, 16vw, 64px); }
  .sentence-hanzi { font-size: clamp(24px, 7vw, 32px); }
  .pinyin { font-size: 1.15rem; }
  .english { font-size: 1rem; }
  .mnemonic { font-size: 0.82rem; }
  .difficulty-buttons { gap: 10px; }
  .difficulty-buttons button { flex: 1 1 100%; }
  .hint { margin-top: 10px; }
}
</style>
</head>
<body>

<button class="theme-toggle" id="theme-toggle" title="Toggle dark mode" aria-label="Toggle dark mode">
  <svg class="theme-icon-sun" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="4"/><path d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M6.34 17.66l-1.41 1.41M19.07 4.93l-1.41 1.41"/></svg>
  <svg class="theme-icon-moon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="display:none"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>
</button>

<header>
  <h1>Chinese Flash Cards</h1>
  <div class="progress" id="progress"></div>
</header>

<div id="app"></div>

<footer>
  <button class="reset-btn" id="reset-btn">Reset Progress</button>
</footer>

<script>
function loadJsonSync(path) {
  const req = new XMLHttpRequest();
  req.open("GET", path, false);
  req.send(null);
  if ((req.status >= 200 && req.status < 300) || (req.status === 0 && req.responseText)) {
    return JSON.parse(req.responseText);
  }
  throw new Error(`Failed to load ${path}: ${req.status}`);
}

// ---------------------------------------------------------------------------
// Vocabulary data source — HSK 1 + HSK 2 (decks use HSK 1 subset + radicals set)
// ---------------------------------------------------------------------------
const DECK_DATA = loadJsonSync("./data/deck-data.json");
const VOCAB = DECK_DATA.vocab;
const HSK1_CARD_COUNT = DECK_DATA.hsk1CardCount;
const HSK1_VOCAB = VOCAB.slice(0, HSK1_CARD_COUNT);
const RADICAL_DECK_CARDS = DECK_DATA.radicals;

const SENTENCE_DATA = loadJsonSync("./data/sentence-data.json");
const SENTENCE_CARDS = SENTENCE_DATA.sentences;

const AUDIO_MANIFEST = loadJsonSync("./data/audio/manifest.json");

// ---------------------------------------------------------------------------
// Cultural tidbits — curated classical quotes with source citations.
// Source repository: Chinese Text Project (ctext.org)
// ---------------------------------------------------------------------------
const TIDBIT_DATA = loadJsonSync("./data/tidbit-data.json");
const CLASSICAL_TIDBITS_RAW = TIDBIT_DATA.classicalTidbitsRaw;
const TIDBIT_MAX_QUOTE_CHARS = TIDBIT_DATA.tidbitMaxQuoteChars;
const TOKEN_SYNONYMS = TIDBIT_DATA.tokenSynonyms;

Object.assign(TOKEN_SYNONYMS, {
  mr: "person",
  miss: "person",
  sir: "person",
  everyone: "person",
  child: "family",
  children: "family",
  brother: "family",
  sister: "family",
  home: "family",
  house: "family",
  live: "family",
  stay: "family",
  table: "home",
  desk: "home",
  chair: "home",
  room: "home",
  door: "home",
  gate: "home",
  clothes: "wear",
  wear: "wear",
  open: "move",
  begin: "start",
  start: "start",
  finish: "end",
  completed: "end",
  end: "end",
  wait: "time",
  maybe: "ability",
  where: "question",
  which: "question",
  what: "question",
  who: "question",
  how: "question",
  why: "question",
  this: "position",
  that: "position",
  these: "position",
  those: "position",
  noon: "time",
  yesterday: "time",
  week: "time",
  each: "time",
  every: "time",
  snow: "weather",
  class: "learn",
  lesson: "learn",
  introduce: "speak",
  welcome: "polite",
  goodbye: "polite",
  please: "polite",
  sorry: "polite",
  waiter: "polite",
  attendant: "polite",
  restaurant: "food",
  hotel: "home",
  shop: "money",
  store: "money",
  cell: "speak",
  bus: "move",
  train: "move",
  station: "move",
  airport: "move",
  airplane: "move",
  road: "move",
  return: "move",
  exit: "move",
  side: "position",
  beside: "position",
  foreign: "distance",
  from: "position",
  thing: "object",
  stuff: "object",
  matter: "object",
  cat: "animal",
  dog: "animal",
  fish: "animal",
  animal: "animal",
  flower: "plant",
  plant: "plant",
  vegetable: "food",
  tea: "drink",
  coffee: "drink",
  milk: "drink",
  cup: "drink",
  rice: "food",
  fruit: "food",
  apple: "food",
  watermelon: "food",
  egg: "food",
  dish: "food",
  cooked: "food",
  birthday: "time",
  diary: "learn",
  pencil: "learn",
  male: "person",
  female: "person",
  black: "color",
  red: "color",
  pretty: "beauty",
  beautiful: "beauty",
  most: "size",
  long: "distance",
  thin: "size",
  color: "color",
  also: "continuation",
  then: "time",
  because: "reason",
  other: "contrast",
  don: "negation",
  t: "negation",
  too: "size",
  although: "contrast",
  there: "exist",
  have: "exist",
  is: "exist",
  be: "exist",
  dance: "exercise",
  play: "exercise",
  watch: "time",
  wristwatch: "time",
  bus: "move",
  bicycle: "move",
  soccer: "exercise",
  basketball: "exercise",
  swim: "exercise",
  washing: "clean",
  wash: "clean",
  open: "move",
  close: "position",
  sit: "position",
  prepared: "prepare",
  prepare: "prepare",
  process: "time",
  ongoing: "time",
  briefly: "time",
  bit: "quantity",
  some: "quantity",
  waiting: "time",
  wait: "time",
});

function normalizeEnglishText(text) {
  return String(text || "")
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, " ")
    .replace(/\s+/g, " ")
    .trim();
}

const RAW_STOPWORDS = new Set([
  "a", "an", "the", "to", "of", "and", "or", "is", "are", "be", "in", "on", "at", "for", "with",
  "from", "it", "its", "this", "that", "these", "those",
]);
const NOISY_MEANING_TOKENS = new Set([
  "side", "form", "particle", "measure", "general", "possessive",
]);

function extractRawMeaningTokens(text) {
  const normalized = normalizeEnglishText(text);
  const tokens = new Set();
  for (const raw of normalized.split(" ")) {
    const tok = raw.trim();
    if (!tok || tok.length < 2) continue;
    if (RAW_STOPWORDS.has(tok)) continue;
    if (NOISY_MEANING_TOKENS.has(tok)) continue;
    tokens.add(tok);
  }
  return tokens;
}

function canonicalToken(token) {
  let t = token;
  if (TOKEN_SYNONYMS[t]) t = TOKEN_SYNONYMS[t];
  if (t.endsWith("ing") && t.length > 5) t = t.slice(0, -3);
  else if (t.endsWith("ed") && t.length > 4) t = t.slice(0, -2);
  else if (t.endsWith("s") && t.length > 4) t = t.slice(0, -1);
  if (TOKEN_SYNONYMS[t]) t = TOKEN_SYNONYMS[t];
  return t;
}

function extractMeaningTokens(text) {
  const normalized = normalizeEnglishText(text);
  const tokens = new Set();
  for (const raw of normalized.split(" ")) {
    const tok = canonicalToken(raw.trim());
    if (!tok || tok.length < 2) continue;
    if (NOISY_MEANING_TOKENS.has(raw.trim())) continue;
    tokens.add(tok);
  }
  return tokens;
}

function overlapCount(a, b) {
  let count = 0;
  for (const token of a) {
    if (b.has(token)) count++;
  }
  return count;
}

const ALL_TIDBIT_CARDS = [...HSK1_VOCAB, ...RADICAL_DECK_CARDS];
const CARD_MEANING_TOKENS = new Map(
  ALL_TIDBIT_CARDS.map((card) => [card.hanzi, extractMeaningTokens(card.english)])
);
const CARD_RAW_MEANING_TOKENS = new Map(
  ALL_TIDBIT_CARDS.map((card) => [card.hanzi, extractRawMeaningTokens(card.english)])
);

function normalizeHanText(text) {
  return String(text || "").replace(/\s+/g, "");
}

const TIDBIT_META = CLASSICAL_TIDBITS_RAW.map((tidbit, index) => ({
  tidbit,
  index,
  tokens: extractMeaningTokens((tidbit.relevance || []).join(" ")),
  rawTokens: extractRawMeaningTokens((tidbit.relevance || []).join(" ")),
  quoteText: normalizeHanText(tidbit.quote),
  quoteLen: normalizeHanText(tidbit.quote).length,
}));

const GENERIC_CANONICAL_TOKENS = new Set([
  "exist", "continuation", "quantity",
]);

// ---------------------------------------------------------------------------
// Audio — local MP3s generated with edge-tts (zh-CN-XiaoxiaoNeural)
// ---------------------------------------------------------------------------
function speak(hanzi) {
  const filename = AUDIO_MANIFEST[hanzi];
  if (!filename) return;
  const audio = new Audio(`./data/audio/${filename}`);
  audio.play().catch(() => {});
}

const PINYIN_TONE_CHAR_MAP = {
  "ā": ["a", 1], "á": ["a", 2], "ǎ": ["a", 3], "à": ["a", 4],
  "ē": ["e", 1], "é": ["e", 2], "ě": ["e", 3], "è": ["e", 4],
  "ī": ["i", 1], "í": ["i", 2], "ǐ": ["i", 3], "ì": ["i", 4],
  "ō": ["o", 1], "ó": ["o", 2], "ǒ": ["o", 3], "ò": ["o", 4],
  "ū": ["u", 1], "ú": ["u", 2], "ǔ": ["u", 3], "ù": ["u", 4],
  "ǖ": ["v", 1], "ǘ": ["v", 2], "ǚ": ["v", 3], "ǜ": ["v", 4],
  "ü": ["v", 5],
};

function pinyinSyllableToNumbered(syllable) {
  let tone = 5;
  let base = "";
  const text = (syllable || "").toLowerCase();

  for (const ch of text) {
    if (PINYIN_TONE_CHAR_MAP[ch]) {
      const [plain, detectedTone] = PINYIN_TONE_CHAR_MAP[ch];
      base += plain;
      if (detectedTone !== 5) tone = detectedTone;
    } else if (/[a-z]/.test(ch)) {
      base += ch;
    }
  }

  if (!base) return "";
  return `${base}${tone}`;
}

function pinyinToAudioKeys(pinyin) {
  return (pinyin || "")
    .replace(/['’]/g, " ")
    .split(/\s+/)
    .map(pinyinSyllableToNumbered)
    .filter(Boolean);
}

// Candidate pinyin-to-anchor map. Only entries that pass English-word guardrails are used.
const PHONETIC_CONFIG = loadJsonSync("./data/phonetic-config.json");
const PHONETIC_ANCHOR_CANDIDATES = PHONETIC_CONFIG.phoneticAnchorCandidates;
const ENGLISH_SOUND_ANCHOR_WORDS = new Set(PHONETIC_CONFIG.englishSoundAnchorWords);

function isEnglishAnchorWord(word) {
  return ENGLISH_SOUND_ANCHOR_WORDS.has(String(word || "").toUpperCase());
}

function canonicalizeSoundAnchorPhrase(phrase) {
  const text = String(phrase || "").trim();
  if (!text) return "";
  const body = text.replace(/^Think of\s+/i, "").replace(/[.?!]+$/, "").trim();
  if (!body) return "";
  const words = body.match(/[A-Za-z]+/g) || [];
  if (words.length === 0) return "";
  const upperWords = words.map((word) => word.toUpperCase());
  if (!upperWords.every((word) => isEnglishAnchorWord(word))) return "";
  return buildIntelligibleAnchorPhrase(upperWords);
}

function buildIntelligibleAnchorPhrase(words) {
  if (words.length === 0) return "";
  if (words.length === 1) return `Think of ${words[0]}.`;
  return `Think of ${words.join(", ")}.`;
}

function getSoundAnchor(card) {
  const keys = pinyinToAudioKeys(card.pinyin);
  if (keys.length === 0) return "";
  const parts = keys.map((key) => {
    const plain = key.replace(/[1-5]$/, "").replaceAll("v", "u");
    return String(PHONETIC_ANCHOR_CANDIDATES[plain] || "").toUpperCase();
  });
  if (parts.some((part) => !part)) return "";
  if (!parts.every((part) => isEnglishAnchorWord(part))) return "";
  return canonicalizeSoundAnchorPhrase(buildIntelligibleAnchorPhrase(parts));
}

function mergeSoundAnchorAndStory(soundAnchor, story) {
  const anchor = canonicalizeSoundAnchorPhrase(soundAnchor);
  const text = String(story || "").trim();
  if (!anchor) return text;
  if (!text) return anchor;
  const anchorWords = anchor
    .replace(/^Think of\s+/i, "")
    .replace(/[.?!]+$/, "")
    .split(/,\s*/)
    .map((word) => word.trim())
    .filter(Boolean);
  const hasAllAnchorWords = anchorWords.every((word) => {
    const escaped = word.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    return new RegExp(`(?<![A-Z\\-])${escaped}(?![A-Z\\-])`).test(text);
  });
  if (hasAllAnchorWords) return text;
  const escapedAnchor = anchor.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const anchorPattern = new RegExp(escapedAnchor, "i");
  if (anchorPattern.test(text)) return text.replace(anchorPattern, anchor);
  return `${anchor} ${text}`;
}

function normalizeMnemonicData(card) {
  const raw = card.mnemonicData;
  if (raw && typeof raw === "object") {
    const soundAnchor = canonicalizeSoundAnchorPhrase(raw.soundAnchor);
    const story = String(raw.story || "").trim();
    const components = Array.isArray(raw.components) ? raw.components : [];
    return { soundAnchor, story, components };
  }
  const parsed = parseMnemonic(card);
  return {
    soundAnchor: getSoundAnchor(card),
    story: parsed.text,
    components: parsed.chips.map((item) => ({ hanzi: item.hanzi, meaning: item.meaning })),
  };
}


// ---------------------------------------------------------------------------
// Progressive Web App setup
// ---------------------------------------------------------------------------
function initPWA() {
  const isWebProtocol = location.protocol === "https:" || location.protocol === "http:";
  if (!isWebProtocol || !("serviceWorker" in navigator)) return;

  navigator.serviceWorker.register("./sw.js").catch((err) => {
    console.error("Service worker registration failed:", err);
  });
}

// ---------------------------------------------------------------------------
// Persistence — localStorage
// ---------------------------------------------------------------------------
const LEGACY_STORAGE_KEY = "chinese-flash-cards-progress";
const DECK_STORAGE_KEYS = {
  hanzi_to_english: "hanzi_to_english_progress",
  english_to_hanzi: "english_to_hanzi_progress",
  radicals_to_english: "radicals_to_english_progress",
  sentence_to_english: "sentence_to_english_progress",
};
const ACTIVE_DECK_STORAGE_KEY = "chinese-flash-cards-active-deck";
const TIDBIT_SALT_KEY = "chinese-flash-cards-tidbit-salt";
const NEW_CARDS_PER_SESSION = 10;

const DECKS = {
  hanzi_to_english: {
    id: "hanzi_to_english",
    title: "Hanzi to English",
    subtitle: "See Hanzi, recall the English meaning.",
    cards: HSK1_VOCAB,
    mode: "hanzi_to_english",
  },
  english_to_hanzi: {
    id: "english_to_hanzi",
    title: "English to Hanzi",
    subtitle: "See English, recall the Chinese characters.",
    cards: HSK1_VOCAB,
    mode: "english_to_hanzi",
  },
  radicals_to_english: {
    id: "radicals_to_english",
    title: "Radicals to English",
    subtitle: "See radicals, recall the English meaning.",
    cards: RADICAL_DECK_CARDS,
    mode: "radicals_to_english",
  },
  sentence_to_english: {
    id: "sentence_to_english",
    title: "Sentences",
    subtitle: "See a sentence, recall the English meaning.",
    cards: SENTENCE_CARDS,
    mode: "sentence_to_english",
  },
};

function loadJson(key, fallback = {}) {
  try {
    return JSON.parse(localStorage.getItem(key)) || fallback;
  } catch {
    return fallback;
  }
}

function saveJson(key, data) {
  localStorage.setItem(key, JSON.stringify(data));
}

function getCardId(card) {
  return card.id || card.hanzi;
}

function loadDeckProgress(deckId) {
  return loadJson(DECK_STORAGE_KEYS[deckId], {});
}

function saveDeckProgress(deckId, data) {
  saveJson(DECK_STORAGE_KEYS[deckId], data);
}

function migrateLegacyProgress() {
  const legacy = loadJson(LEGACY_STORAGE_KEY, null);
  if (!legacy || typeof legacy !== "object") return;
  const existing = loadDeckProgress("hanzi_to_english");
  if (Object.keys(existing).length === 0) {
    saveDeckProgress("hanzi_to_english", legacy);
  }
}

function getSavedActiveDeckId() {
  const saved = localStorage.getItem(ACTIVE_DECK_STORAGE_KEY);
  return DECKS[saved] ? saved : null;
}

function saveActiveDeckId(deckId) {
  localStorage.setItem(ACTIVE_DECK_STORAGE_KEY, deckId);
}

function getDailyTidbitSalt() {
  const today = todayStr();
  try {
    const saved = JSON.parse(localStorage.getItem(TIDBIT_SALT_KEY) || "null");
    if (saved && saved.date === today && Number.isFinite(saved.salt)) {
      return saved.salt;
    }
    const salt = Math.floor(Math.random() * 1_000_000_000);
    localStorage.setItem(TIDBIT_SALT_KEY, JSON.stringify({ date: today, salt }));
    return salt;
  } catch {
    return 0;
  }
}

// ---------------------------------------------------------------------------
// Spaced repetition — simplified SM-2
// ---------------------------------------------------------------------------
function todayStr() {
  return new Date().toISOString().slice(0, 10);
}

function shuffle(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function escapeHtml(text) {
  return String(text || "")
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#39;");
}

function hashString(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = (hash * 31 + str.charCodeAt(i)) >>> 0;
  }
  return hash;
}

function getCulturalTidbitForCard(card) {
  const key = card.hanzi || "";
  const seed = hashString(`${key}|${todayStr()}|${getDailyTidbitSalt()}`);
  const cardTokens = CARD_MEANING_TOKENS.get(key) || new Set();
  const cardRawTokens = CARD_RAW_MEANING_TOKENS.get(key) || new Set();
  if (cardTokens.size === 0 && cardRawTokens.size === 0) return null;

  const scored = [];
  for (const meta of TIDBIT_META) {
    if (meta.quoteLen > TIDBIT_MAX_QUOTE_CHARS) continue;
    const canonicalScore = overlapCount(cardTokens, meta.tokens);
    const rawScore = overlapCount(cardRawTokens, meta.rawTokens);
    const canonicalSpecificScore = [...cardTokens].reduce(
      (n, token) => n + (!GENERIC_CANONICAL_TOKENS.has(token) && meta.tokens.has(token) ? 1 : 0),
      0
    );
    // Require direct lexical overlap, or at least one non-generic conceptual overlap.
    if (rawScore === 0 && canonicalSpecificScore === 0) continue;
    const score = rawScore * 3 + canonicalSpecificScore * 2 + canonicalScore;
    scored.push({ ...meta, score, rawScore, canonicalScore, canonicalSpecificScore });
  }
  if (scored.length === 0) return null;

  scored.sort((a, b) => {
    if (b.score !== a.score) return b.score - a.score;
    if (a.quoteLen !== b.quoteLen) return a.quoteLen - b.quoteLen;
    return a.index - b.index;
  });
  const topScore = scored[0].score;
  // Keep a small pool of strong candidates to reduce repetition.
  const best = scored.filter((item) => item.score >= topScore - 1).slice(0, 6);
  return best[seed % best.length].tidbit;
}

function getTidbitAttribution(tidbit) {
  const source = tidbit.source || "";
  if (source.includes("道德经")) return "Laozi, Tao Te Ching";
  if (source.includes("孙子兵法") || source.includes("孙子")) return "Sun Tzu, The Art of War";
  if (source.includes("论语")) return "Confucius, Analects";
  if (source.includes("大学")) return "Great Learning";
  if (source.includes("中庸")) return "Doctrine of the Mean";
  if (source.includes("诗经")) return "Classic of Poetry";
  if (source.includes("孟子")) return "Mencius";
  if (source.includes("庄子")) return "Zhuangzi";
  if (source.includes("墨子")) return "Mozi";
  if (source.includes("荀子")) return "Xunzi";
  if (source.includes("史记")) return "Sima Qian, Records of the Grand Historian";
  if (source.includes("左传")) return "Zuo Commentary";
  if (source.includes("国语")) return "Discourses of the States";
  if (source.includes("战国策")) return "Strategies of the Warring States";
  if (source.includes("杜甫")) return "Du Fu";
  if (source.includes("礼记")) return "Book of Rites";
  return source || "Classical Chinese text";
}

function buildQueue(cards, progress) {
  const today = todayStr();
  const due = [];
  const unseen = [];

  for (const card of cards) {
    const id = getCardId(card);
    const p = progress[id];
    if (!p) unseen.push(card);
    else if (p.due <= today) due.push(card);
  }

  const baseQueue = [...shuffle(due), ...shuffle(unseen).slice(0, NEW_CARDS_PER_SESSION)];
  if (baseQueue.length === 0) return baseQueue;
  return baseQueue;
}

function rateCard(card, progress, difficulty, deckId) {
  const id = getCardId(card);
  const p = progress[id] || { interval: 0, ease: 2.5, repetitions: 0 };
  let { interval, ease, repetitions } = p;

  if (difficulty === "hard") {
    interval = 1;
    ease = Math.max(1.3, ease - 0.2);
    repetitions = 0;
  } else if (difficulty === "medium") {
    if (repetitions === 0) interval = 1;
    else if (repetitions === 1) interval = 6;
    else interval = Math.round(interval * ease);
    repetitions++;
  } else if (difficulty === "easy") {
    if (repetitions === 0) interval = 4;
    else interval = Math.round(interval * ease * 1.3);
    ease = Math.min(3.0, ease + 0.15);
    repetitions++;
  }

  const due = new Date();
  due.setDate(due.getDate() + interval);

  progress[id] = {
    interval,
    ease,
    repetitions,
    due: due.toISOString().slice(0, 10),
  };

  saveDeckProgress(deckId, progress);
}

function rateCardFromQuizResult(card, progress, correct, deckId) {
  const difficulty = correct ? "easy" : "hard";
  rateCard(card, progress, difficulty, deckId);
}

function pickMultipleChoiceOptions(card, deck, allCards, count = 4) {
  const isEnglishToHanzi = deck.mode === "english_to_hanzi";
  const correct = isEnglishToHanzi ? card.hanzi : card.english;
  const seen = new Set([correct]);
  const pool = [];
  for (const c of allCards) {
    const v = isEnglishToHanzi ? c.hanzi : c.english;
    if (v && !seen.has(v)) {
      seen.add(v);
      pool.push(v);
    }
  }
  const distractors = shuffle(pool).slice(0, count - 1);
  return shuffle([correct, ...distractors]);
}

// ---------------------------------------------------------------------------
// UI
// ---------------------------------------------------------------------------
const app = document.getElementById("app");
const progressEl = document.getElementById("progress");
const resetBtn = document.getElementById("reset-btn");
const RADICAL_MEANINGS = Object.fromEntries(
  RADICAL_DECK_CARDS.map((card) => [card.hanzi, card.english])
);
const RADICAL_SIDE_FORM_FULL_FORM = {
  "讠": "言",
  "氵": "水",
  "扌": "手",
  "忄": "心",
  "亻": "人",
  "钅": "金",
  "纟": "糸",
  "阝": "阜",
};
const RADICAL_SIDE_FORM_SHIFT = {
  "讠": "0.12em",
  "氵": "0.1em",
  "扌": "0.1em",
  "忄": "0.1em",
  "亻": "0.1em",
  "钅": "0.1em",
  "纟": "0.1em",
  "阝": "0.16em",
};

let activeDeckId = null;
let progress = {};
let queue = [];
let lessonQueue = [...queue];
let currentIndex = 0;
let stage = 0;
let quizMode = false;
let quizQueue = [];
let quizIndex = 0;

function getActiveDeck() {
  return activeDeckId ? DECKS[activeDeckId] : null;
}

function setActiveDeck(deckId) {
  activeDeckId = deckId;
  saveActiveDeckId(deckId);
  progress = loadDeckProgress(deckId);
  startNewLessonFromProgress();
}

function getRadicalSideFormFullForm(deck, card) {
  if (deck.mode !== "radicals_to_english") return "";
  return RADICAL_SIDE_FORM_FULL_FORM[card.hanzi] || "";
}

function getRadicalSideFormShift(deck, card) {
  if (deck.mode !== "radicals_to_english") return "";
  return RADICAL_SIDE_FORM_SHIFT[card.hanzi] || "";
}

function startNewLessonFromProgress() {
  const deck = getActiveDeck();
  queue = deck ? buildQueue(deck.cards, progress) : [];
  lessonQueue = [...queue];
  currentIndex = 0;
  quizMode = false;
}

function replayLesson() {
  if (lessonQueue.length === 0) return;
  queue = shuffle(lessonQueue);
  currentIndex = 0;
  quizMode = false;
  renderStudyDeck();
}

function startQuiz() {
  if (lessonQueue.length < 2) return;
  quizMode = true;
  quizQueue = shuffle([...lessonQueue]);
  quizIndex = 0;
  renderStudyDeck();
}

function endQuiz() {
  quizMode = false;
  quizQueue = [];
  quizIndex = 0;
  renderStudyDeck();
}

function parseRoute() {
  const raw = location.hash.replace(/^#\/?/, "");
  if (!raw) return { route: "decks", params: new URLSearchParams() };
  const [path, query = ""] = raw.split("?");
  const route = ["decks", "study"].includes(path) ? path : "decks";
  return { route, params: new URLSearchParams(query) };
}

function parseMnemonic(card) {
  const mnemonic = card.mnemonic || "";
  const componentPattern = /([\u3400-\u9fff]+)\s*\(([^)]+)\)/g;
  const chips = [];
  const seen = new Set();

  for (const match of mnemonic.matchAll(componentPattern)) {
    const hanzi = match[1].trim();
    const meaning = match[2].trim();
    const key = `${hanzi}|${meaning}`;
    if (!hanzi || !meaning || seen.has(key)) continue;
    seen.add(key);
    chips.push({ hanzi, meaning });
  }

  let text = mnemonic.trim();
  const firstStop = text.search(/[。.!?]/);
  if (firstStop !== -1) {
    const head = text.slice(0, firstStop + 1);
    if (/[\u3400-\u9fff]+\s*\([^)]+\)/.test(head)) {
      text = text.slice(firstStop + 1).trim();
    }
  }

  if (!text) {
    text = mnemonic
      .replace(componentPattern, "$1")
      .replace(/\s*[+＋=＝]\s*/g, " ")
      .replace(/\s+/g, " ")
      .trim();
  }

  // Mnemonic line should be English-only; keep Hanzi in chips above.
  text = text
    .replace(/[\u3400-\u9fff]+/g, " ")
    .replace(/\([^)]*\)/g, " ")
    .replace(/\s*[+＋=＝]\s*/g, " ")
    .replace(/\s*[-–—]\s*/g, " — ")
    .replace(/^[^a-zA-Z0-9]+/, "")
    .replace(/\s+/g, " ")
    .trim();

  // Keep mnemonic concise: max two short sentences.
  const sentenceParts = text.match(/[^.!?]+[.!?]?/g) || [];
  if (sentenceParts.length > 2) {
    text = sentenceParts.slice(0, 2).join(" ").trim();
  }

  return { text, chips };
}

function buildMnemonicAndChips(card, options = {}) {
  const includeSoundAnchor = options.includeSoundAnchor !== false;
  const includeChips = options.includeChips !== false;
  const mnemonicData = normalizeMnemonicData(card);
  const chips = [];
  const seen = new Set();
  const pushChip = (hanzi, meaning) => {
    const h = (hanzi || "").trim();
    const m = (meaning || "").trim();
    if (!h || !m) return;
    const key = `${h}|${m}`;
    if (seen.has(key)) return;
    seen.add(key);
    chips.push({ hanzi: h, meaning: m });
  };

  for (const item of mnemonicData.components) {
    pushChip(item.hanzi, item.meaning);
  }

  if (includeChips) {
    const parsed = parseMnemonic(card);
    for (const item of parsed.chips) {
      pushChip(item.hanzi, item.meaning);
    }

    const equalPattern = /([\u3400-\u9fff]+)\s*=\s*([^。.!?;；]+)/g;
    for (const match of (card.mnemonic || "").matchAll(equalPattern)) {
      const token = match[1].trim();
      const meaning = match[2].trim();
      if (!token || !meaning) continue;
      for (const ch of token) {
        pushChip(ch, meaning);
      }
    }

    for (const ch of card.hanzi) {
      const covered = chips.some((item) => item.hanzi.includes(ch));
      if (covered) continue;
      const meaning = RADICAL_MEANINGS[ch] || "word component";
      pushChip(ch, meaning);
    }
    if (chips.length === 0) pushChip(card.hanzi, "word component");
  }
  if (includeChips) {
    // Avoid self-referential chips (notably radical cards like 木 -> "木 wood/tree").
    const filtered = chips.filter((item) => item.hanzi !== card.hanzi);
    chips.length = 0;
    chips.push(...filtered);
  }

  const story = String(mnemonicData.story || "");
  const text = includeSoundAnchor
    ? mergeSoundAnchorAndStory(mnemonicData.soundAnchor, story)
    : story.trim();
  return { text, chips };
}

function getDeckDueCount(deck) {
  const today = todayStr();
  const deckProgress = loadDeckProgress(deck.id);
  let count = 0;
  for (const card of deck.cards) {
    const p = deckProgress[getCardId(card)];
    if (!p || p.due <= today) count++;
  }
  return count;
}

function renderQuizCard() {
  const deck = getActiveDeck();
  if (!deck || quizIndex >= quizQueue.length) {
    endQuiz();
    return;
  }
  const card = quizQueue[quizIndex];
  const options = pickMultipleChoiceOptions(card, deck, deck.cards);
  if (options.length < 2) {
    quizIndex++;
    renderStudyDeck();
    return;
  }
  const isEnglishToHanzi = deck.mode === "english_to_hanzi";
  const isSentence = deck.mode === "sentence_to_english";
  const correctValue = isEnglishToHanzi ? card.hanzi : card.english;

  progressEl.textContent = `Quiz · ${quizIndex + 1} of ${quizQueue.length}`;
  let html = '<div class="card" id="quiz-card">';
  if (isEnglishToHanzi) {
    html += `<div class="english">${escapeHtml(card.english)}</div>`;
    html += '<div class="hint">Choose the correct character:</div>';
  } else if (isSentence) {
    html += `<div class="sentence-hanzi">${escapeHtml(card.hanzi)}</div>`;
    html += `<div class="sentence-pinyin">${escapeHtml(card.pinyin)}</div>`;
    html += '<button class="speaker-btn" id="quiz-speak-btn" title="Play pronunciation">&#128264;</button>';
    html += '<div class="hint">Choose the correct translation:</div>';
  } else {
    const sideFormFullForm = getRadicalSideFormFullForm(deck, card);
    const sideFormShift = getRadicalSideFormShift(deck, card);
    if (sideFormShift) {
      html += `<div class="hanzi"><span class="radical-side-glyph" style="--side-shift:${escapeHtml(sideFormShift)}">${escapeHtml(card.hanzi)}</span></div>`;
    } else {
      html += `<div class="hanzi">${escapeHtml(card.hanzi)}</div>`;
    }
    if (sideFormFullForm) {
      html += `<div class="radical-side-note">side form of ${escapeHtml(sideFormFullForm)}</div>`;
    }
    html += `<div class="pinyin">${escapeHtml(card.pinyin)}</div>`;
    html += '<button class="speaker-btn" id="quiz-speak-btn" title="Play pronunciation">&#128264;</button>';
    html += '<div class="hint">Choose the correct meaning:</div>';
  }
  html += '<div class="quiz-options">';
  for (const opt of options) {
    html += `<button class="quiz-option" data-value="${escapeHtml(String(opt))}">${escapeHtml(String(opt))}</button>`;
  }
  html += "</div>";
  html += '<button class="quiz-idk-btn" id="quiz-idk-btn">I don\'t know</button>';
  html += "</div>";
  html += '<div class="deck-back-link"><a href="#/decks">Back to deck selection</a></div>';
  app.innerHTML = html;

  function applyQuizFeedback(correct, clickedBtn) {
    for (const b of app.querySelectorAll(".quiz-option")) {
      b.disabled = true;
      b.style.pointerEvents = "none";
    }
    const idkBtn = document.getElementById("quiz-idk-btn");
    if (idkBtn) {
      idkBtn.disabled = true;
      idkBtn.style.pointerEvents = "none";
    }
    if (clickedBtn) clickedBtn.classList.add(correct ? "correct" : "wrong");
    if (!correct) {
      for (const b of app.querySelectorAll(".quiz-option")) {
        if (b.dataset.value === correctValue) b.classList.add("reveal-correct");
      }
    }
    rateCardFromQuizResult(card, progress, correct, deck.id);
    quizIndex++;
    setTimeout(renderStudyDeck, 1200);
  }

  const quizSpeakBtn = document.getElementById("quiz-speak-btn");
  if (quizSpeakBtn) {
    quizSpeakBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      speak(card.hanzi);
    });
  }

  for (const btn of app.querySelectorAll(".quiz-option")) {
    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      const correct = btn.dataset.value === correctValue;
      applyQuizFeedback(correct, btn);
    });
  }
  const idkBtn = document.getElementById("quiz-idk-btn");
  if (idkBtn) {
    idkBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      applyQuizFeedback(false, null);
    });
  }
}

function renderDeckSelection() {
  progressEl.textContent = "Choose a deck";
  let html = '<section class="study-page">';

  for (const deck of Object.values(DECKS)) {
    const dueCount = getDeckDueCount(deck);
    const canQuiz = deck.cards.length >= 2;
    html += '<div class="deck-row" style="margin:10px 0;display:flex;align-items:stretch;gap:8px;">';
    html += `<a class="chip-link" style="flex:1;display:block;padding:12px 14px;" href="#/study?deck=${deck.id}">`;
    html += `<strong>${escapeHtml(deck.title)}</strong><br>`;
    html += `<small>${escapeHtml(deck.subtitle)} · ${dueCount} due/new</small>`;
    html += "</a>";
    if (canQuiz) {
      html += `<a class="chip-link quiz-btn" style="flex-shrink:0;display:flex;align-items:center;align-self:center;padding:8px 14px;" href="#/study?deck=${deck.id}&quiz=1">Quiz</a>`;
    }
    html += "</div>";
  }

  html += "</section>";
  app.innerHTML = html;
}

function renderSentenceCard(deck, card) {
  stage = 0;
  render();

  function render() {
    const finalStage = 2;
    let html = '<div class="card" id="flashcard">';

    html += `<div class="sentence-hanzi">${escapeHtml(card.hanzi)}</div>`;

    if (stage >= 1) {
      html += `<div class="sentence-pinyin">${escapeHtml(card.pinyin)}</div>`;
      html += '<button class="speaker-btn" id="speak-btn" title="Play pronunciation">&#128264;</button>';
    }

    if (stage >= finalStage) {
      html += `<div class="sentence-english">${escapeHtml(card.english)}</div>`;

      const vocabWords = card.vocabWords || [];
      if (vocabWords.length > 0) {
        html += '<div class="word-gloss-chips">';
        for (const word of vocabWords) {
          html += '<span class="word-gloss-chip">';
          html += `<span class="chip-hanzi">${escapeHtml(word.hanzi)}</span>`;
          html += ` ${escapeHtml(word.english)}`;
          html += "</span>";
        }
        html += "</div>";
      }
    }

    if (stage >= finalStage) {
      html += '<button class="reset-btn reset-card-btn" id="reset-card-btn">Reset card</button>';
    }

    const hints = ["tap to reveal pinyin", "tap to reveal translation", "tap for next"];
    html += `<div class="hint">${hints[stage]}</div>`;

    html += "</div>";
    html += '<div class="deck-back-link"><a href="#/decks">Back to deck selection</a></div>';
    app.innerHTML = html;

    document.getElementById("flashcard").addEventListener("click", (e) => {
      if (e.target.closest("a, button")) return;
      if (stage < finalStage) {
        stage++;
        render();
      } else {
        currentIndex++;
        renderStudyDeck();
      }
    });

    const speakBtn = document.getElementById("speak-btn");
    if (speakBtn) {
      speakBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        speak(card.hanzi);
      });
    }

    const resetCardBtn = document.getElementById("reset-card-btn");
    if (resetCardBtn) {
      resetCardBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        stage = 0;
        render();
      });
    }
  }
}

function renderStudyDeck() {
  const deck = getActiveDeck();
  if (!deck) {
    renderDeckSelection();
    return;
  }

  if (quizMode && quizQueue.length > 0) {
    renderQuizCard();
    return;
  }

  if (quizMode && quizQueue.length === 0) {
    endQuiz();
    return;
  }

  if (currentIndex >= queue.length) {
    progressEl.textContent = "";
    let html =
      '<div class="done"><div class="emoji">&#127881;</div>' +
      "All done for today!<br>" +
      '<small style="color:var(--text-subtle)">Come back tomorrow for more review.</small>';
    html += '<div style="margin-top:14px;"><a class="reset-btn" href="#/decks">Deck selection</a></div>';
    if (lessonQueue.length > 0) {
      html += '<div style="margin-top:14px;"><button class="reset-btn" id="replay-lesson-btn">Replay lesson</button></div>';
      if (lessonQueue.length >= 2) {
        html += '<div style="margin-top:14px;"><button class="reset-btn quiz-btn" id="take-quiz-btn">Tap to take quiz</button></div>';
      }
    }
    html += "</div>";
    app.innerHTML = html;
    const replayBtn = document.getElementById("replay-lesson-btn");
    if (replayBtn) replayBtn.addEventListener("click", replayLesson);
    const quizBtn = document.getElementById("take-quiz-btn");
    if (quizBtn) quizBtn.addEventListener("click", startQuiz);
    return;
  }

  const card = queue[currentIndex];

  progressEl.textContent = `${deck.title} · Card ${currentIndex + 1} of ${queue.length}`;
  stage = 0;

  if (deck.mode === "sentence_to_english") {
    renderSentenceCard(deck, card);
    return;
  }

  render();

  function render() {
    const isEnglishToHanzi = deck.mode === "english_to_hanzi";
    const finalStage = 2;
    const sideFormFullForm = getRadicalSideFormFullForm(deck, card);
    const sideFormShift = getRadicalSideFormShift(deck, card);
    let html = '<div class="card" id="flashcard">';
    const parsedMnemonic = stage >= finalStage ? buildMnemonicAndChips(card) : null;
    const tidbit = stage >= finalStage ? getCulturalTidbitForCard(card) : null;

    if (isEnglishToHanzi) {
      html += `<div class="english">${card.english}</div>`;
    } else {
      if (sideFormShift) {
        html += `<div class="hanzi"><span class="radical-side-glyph" style="--side-shift:${escapeHtml(sideFormShift)}">${escapeHtml(card.hanzi)}</span></div>`;
      } else {
        html += `<div class="hanzi">${escapeHtml(card.hanzi)}</div>`;
      }
      if (sideFormFullForm) {
        html += `<div class="radical-side-note">side form of ${escapeHtml(sideFormFullForm)}</div>`;
      }
    }

    if (stage >= 1) {
      html += `<div class="pinyin">${card.pinyin}</div>`;
      html += '<button class="speaker-btn" id="speak-btn" title="Play pronunciation">&#128264;</button>';
    }

    if (stage >= finalStage) {
      if (isEnglishToHanzi) {
        html += `<div class="hanzi">${card.hanzi}</div>`;
      } else {
        html += `<div class="english">${card.english}</div>`;
      }
      if (parsedMnemonic.text) {
        html += `<div class="mnemonic">${escapeHtml(parsedMnemonic.text)}</div>`;
      }
      if (parsedMnemonic.chips.length > 0) {
        html += '<div class="related-radicals">';
        for (const item of parsedMnemonic.chips) {
          html += `<span class="chip-link">${escapeHtml(item.hanzi)} ${escapeHtml(item.meaning)}</span>`;
        }
        html += "</div>";
      }
      if (tidbit) {
        html += '<div class="cultural-tidbit">';
        html += `<div class="cultural-quote">${escapeHtml(tidbit.quote)}</div>`;
        if (tidbit.translation) {
          html += `<div class="cultural-translation">${escapeHtml(tidbit.translation)}</div>`;
        }
        const attribution = getTidbitAttribution(tidbit);
        html += '<div class="cultural-source">';
        html += `&mdash; ${escapeHtml(attribution)}`;
        if (tidbit.source && tidbit.source !== attribution) {
          html += ` · ${escapeHtml(tidbit.source)}`;
        }
        html += ` · <a href="${escapeHtml(tidbit.url)}" target="_blank" rel="noopener noreferrer">source</a>`;
        html += "</div>";
        html += "</div>";
      }
    }

    if (stage >= finalStage) {
      html += '<button class="reset-btn reset-card-btn" id="reset-card-btn">Reset card</button>';
    }

    const hints = ["tap to reveal pinyin", "tap to reveal full answer", "tap for next"];
    html += `<div class="hint">${hints[stage]}</div>`;

    html += "</div>";
    html += '<div class="deck-back-link"><a href="#/decks">Back to deck selection</a></div>';
    app.innerHTML = html;

    document.getElementById("flashcard").addEventListener("click", (e) => {
      if (e.target.closest("a, button")) return;
      if (stage < finalStage) {
        stage++;
        render();
      } else {
        currentIndex++;
        renderStudyDeck();
      }
    });

    const speakBtn = document.getElementById("speak-btn");
    if (speakBtn) {
      speakBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        speak(card.hanzi);
      });
    }

    const resetCardBtn = document.getElementById("reset-card-btn");
    if (resetCardBtn) {
      resetCardBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        stage = 0;
        render();
      });
    }
  }
}

function renderRoute() {
  const { route, params } = parseRoute();
  resetBtn.style.display = route === "study" ? "inline-block" : "none";

  if (route === "decks") {
    renderDeckSelection();
    return;
  }

  const requestedDeckId = params.get("deck") || activeDeckId || getSavedActiveDeckId();
  if (!requestedDeckId || !DECKS[requestedDeckId]) {
    location.hash = "#/decks";
    return;
  }
  if (activeDeckId !== requestedDeckId) setActiveDeck(requestedDeckId);
  if (params.get("quiz") === "1") {
    startQuiz();
    history.replaceState(null, "", "#/study");
  }
  renderStudyDeck();
}

resetBtn.addEventListener("click", () => {
  const deck = getActiveDeck();
  if (!deck) return;
  if (confirm(`Reset progress for "${deck.title}"? This cannot be undone.`)) {
    localStorage.removeItem(DECK_STORAGE_KEYS[deck.id]);
    progress = {};
    startNewLessonFromProgress();
    renderRoute();
  }
});

window.addEventListener("hashchange", renderRoute);
migrateLegacyProgress();
if (!location.hash) location.hash = "#/decks";
renderRoute();
initPWA();

// ---------------------------------------------------------------------------
// Theme toggle (light / dark)
// ---------------------------------------------------------------------------
const THEME_STORAGE_KEY = "chinese-flash-cards-theme";
const themeToggle = document.getElementById("theme-toggle");
const themeIconSun = themeToggle.querySelector(".theme-icon-sun");
const themeIconMoon = themeToggle.querySelector(".theme-icon-moon");
const themeColorMeta = document.getElementById("theme-color-meta");

function getSystemTheme() {
  return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
}

function getEffectiveTheme() {
  const saved = localStorage.getItem(THEME_STORAGE_KEY);
  return saved === "light" || saved === "dark" ? saved : getSystemTheme();
}

function applyTheme() {
  const theme = getEffectiveTheme();
  const hasOverride = localStorage.getItem(THEME_STORAGE_KEY);
  if (hasOverride) document.documentElement.setAttribute("data-theme", theme);
  else document.documentElement.removeAttribute("data-theme");
  themeColorMeta.content = theme === "dark" ? "#1a1a1a" : "#ea580c";
  themeIconSun.style.display = theme === "dark" ? "none" : "block";
  themeIconMoon.style.display = theme === "dark" ? "block" : "none";
  themeToggle.setAttribute("aria-label", theme === "dark" ? "Switch to light mode" : "Switch to dark mode");
  themeToggle.setAttribute("title", theme === "dark" ? "Switch to light mode" : "Switch to dark mode");
}

function cycleTheme() {
  const current = getEffectiveTheme();
  const next = current === "dark" ? "light" : "dark";
  localStorage.setItem(THEME_STORAGE_KEY, next);
  applyTheme();
}

applyTheme();
themeToggle.addEventListener("click", cycleTheme);

window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", () => {
  if (!localStorage.getItem(THEME_STORAGE_KEY)) applyTheme();
});
</script>
</body>
</html>
