<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="theme-color" content="#ea580c">
<meta name="description" content="HSK flash cards with spaced repetition for learning Chinese.">
<link rel="manifest" href="./manifest.webmanifest">
<link rel="icon" href="./icons/icon.svg" type="image/svg+xml">
<link rel="apple-touch-icon" href="./icons/apple-touch-icon-180.png">
<title>Chinese Flash Cards — Four Decks</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  background: #f0f2f5;
  min-height: 100vh;
  min-height: 100dvh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: max(16px, env(safe-area-inset-top)) max(16px, env(safe-area-inset-right)) max(16px, env(safe-area-inset-bottom)) max(16px, env(safe-area-inset-left));
  color: #333;
  overscroll-behavior-y: none;
  -webkit-tap-highlight-color: transparent;
}

header {
  text-align: center;
  margin-bottom: 24px;
  width: 100%;
  max-width: 420px;
}

header h1 {
  font-size: 1.4rem;
  font-weight: 600;
  color: #555;
}

.progress {
  font-size: 0.9rem;
  color: #888;
  margin-top: 6px;
}

.card {
  background: #fff;
  border-radius: 16px;
  box-shadow: 0 4px 24px rgba(0, 0, 0, 0.08);
  padding: clamp(28px, 6vw, 48px) clamp(20px, 6vw, 40px);
  width: 100%;
  max-width: 420px;
  text-align: center;
  cursor: pointer;
  user-select: none;
  min-height: clamp(260px, 56vh, 420px);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  transition: box-shadow 0.2s;
  touch-action: manipulation;
}

.card:hover {
  box-shadow: 0 6px 32px rgba(0, 0, 0, 0.12);
}

.hanzi {
  font-size: 72px;
  font-weight: 700;
  line-height: 1.2;
  margin-bottom: 12px;
}

.radical-side-glyph {
  display: inline-block;
  transform: translateX(var(--side-shift, 0));
}

.pinyin {
  font-size: 1.4rem;
  color: #666;
  margin-bottom: 8px;
}

.radical-side-note {
  font-size: 0.82rem;
  color: #8a8a8a;
  margin-bottom: 8px;
}

.english {
  font-size: 1.2rem;
  color: #999;
  margin-bottom: 8px;
}

.mnemonic {
  font-size: 0.85rem;
  color: #777;
  font-style: italic;
  margin-top: 10px;
  margin-bottom: 16px;
  line-height: 1.5;
  max-width: 340px;
}

.hint {
  font-size: 0.8rem;
  color: #bbb;
  margin-top: 12px;
}

.related-radicals {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  justify-content: center;
  margin-top: 12px;
}

.chip-link {
  text-decoration: none;
  border: 1px solid #fed7aa;
  color: #9a3412;
  background: #fff7ed;
  border-radius: 999px;
  padding: 4px 10px;
  font-size: 0.8rem;
}

.cultural-tidbit {
  width: 100%;
  margin-top: 14px;
  border-left: 4px solid #ea580c;
  background: #fef9ef;
  border-radius: 10px;
  padding: 10px 12px;
  text-align: left;
}

.cultural-quote {
  font-size: 1.1rem;
  line-height: 1.45;
  color: #3f3f46;
}

.cultural-source {
  margin-top: 8px;
  font-size: 0.78rem;
  color: #78716c;
}

.cultural-translation {
  margin-top: 8px;
  font-size: 0.88rem;
  line-height: 1.45;
  color: #57534e;
}

.cultural-source a {
  color: #9a3412;
}

.study-page {
  background: #fff;
  border-radius: 16px;
  box-shadow: 0 4px 24px rgba(0, 0, 0, 0.08);
  padding: 20px;
  width: 100%;
  max-width: 420px;
}

.study-page h2 {
  font-size: 1.3rem;
  color: #444;
  margin-bottom: 10px;
}

.study-page p {
  color: #666;
  font-size: 0.95rem;
  line-height: 1.5;
}

.deck-back-link {
  margin-top: auto;
  padding-top: 14px;
  font-size: 0.78rem;
  color: #a3a3a3;
}

.deck-back-link a {
  color: #a3a3a3;
  text-decoration: none;
}

.deck-back-link a:hover {
  color: #888;
  text-decoration: underline;
}


.speaker-btn {
  background: none;
  border: 1px solid #ddd;
  border-radius: 50%;
  width: 44px;
  height: 44px;
  font-size: 1.2rem;
  cursor: pointer;
  color: #888;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-top: 8px;
  transition: background 0.15s, color 0.15s;
}

.speaker-btn:hover {
  background: #f0f0f0;
  color: #555;
}

.difficulty-buttons {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 12px;
  margin-top: 20px;
  width: 100%;
}

.difficulty-buttons button {
  border: none;
  border-radius: 8px;
  padding: 12px 16px;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  color: #fff;
  transition: opacity 0.15s;
  min-width: 96px;
  flex: 1 1 96px;
  touch-action: manipulation;
}

.difficulty-buttons button:hover { opacity: 0.85; }

.btn-hard { background: #e74c3c; }
.btn-medium { background: #f39c12; }
.btn-easy { background: #27ae60; }

.reset-card-btn {
  margin-top: 12px;
}

.done {
  font-size: 1.3rem;
  color: #888;
  text-align: center;
  padding: 40px;
}

.done .emoji {
  font-size: 3rem;
  margin-bottom: 16px;
}

footer {
  margin-top: 24px;
  width: 100%;
  max-width: 420px;
  display: flex;
  justify-content: center;
}

.reset-btn {
  background: none;
  border: 1px solid #ccc;
  border-radius: 6px;
  padding: 6px 14px;
  font-size: 0.8rem;
  color: #999;
  cursor: pointer;
}

.reset-btn:hover { border-color: #999; color: #666; }

.sentence-hanzi {
  font-size: 32px;
  font-weight: 700;
  line-height: 1.5;
  margin-bottom: 12px;
  letter-spacing: 2px;
}

.sentence-pinyin {
  font-size: 1.1rem;
  color: #666;
  margin-bottom: 8px;
  line-height: 1.5;
}

.sentence-english {
  font-size: 1.1rem;
  color: #999;
  margin-bottom: 8px;
  line-height: 1.5;
}

.word-gloss-chips {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  justify-content: center;
  margin-top: 12px;
}

.word-gloss-chip {
  text-decoration: none;
  border: 1px solid #fed7aa;
  color: #9a3412;
  background: #fff7ed;
  border-radius: 999px;
  padding: 4px 10px;
  font-size: 0.8rem;
  display: inline-flex;
  gap: 4px;
  align-items: baseline;
}

.word-gloss-chip .chip-hanzi {
  font-size: 0.95rem;
}

@media (max-width: 480px) {
  body { justify-content: flex-start; }
  header { margin-bottom: 14px; }
  .card { min-height: clamp(240px, 54dvh, 380px); }
  .hanzi { font-size: clamp(52px, 16vw, 64px); }
  .sentence-hanzi { font-size: clamp(24px, 7vw, 32px); }
  .pinyin { font-size: 1.15rem; }
  .english { font-size: 1rem; }
  .mnemonic { font-size: 0.82rem; }
  .difficulty-buttons { gap: 10px; }
  .difficulty-buttons button { flex: 1 1 100%; }
  .hint { margin-top: 10px; }
}
</style>
</head>
<body>

<header>
  <h1>Chinese Flash Cards</h1>
  <div class="progress" id="progress"></div>
</header>

<div id="app"></div>

<footer>
  <button class="reset-btn" id="reset-btn">Reset Progress</button>
</footer>

<script>
function loadJsonSync(path) {
  const req = new XMLHttpRequest();
  req.open("GET", path, false);
  req.send(null);
  if ((req.status >= 200 && req.status < 300) || (req.status === 0 && req.responseText)) {
    return JSON.parse(req.responseText);
  }
  throw new Error(`Failed to load ${path}: ${req.status}`);
}

// ---------------------------------------------------------------------------
// Vocabulary data source — HSK 1 + HSK 2 (decks use HSK 1 subset + radicals set)
// ---------------------------------------------------------------------------
const DECK_DATA = loadJsonSync("./data/deck-data.json");
const VOCAB = DECK_DATA.vocab;
const HSK1_CARD_COUNT = DECK_DATA.hsk1CardCount;
const HSK1_VOCAB = VOCAB.slice(0, HSK1_CARD_COUNT);
const RADICAL_DECK_CARDS = DECK_DATA.radicals;

const SENTENCE_DATA = loadJsonSync("./data/sentence-data.json");
const SENTENCE_CARDS = SENTENCE_DATA.sentences;

const AUDIO_MANIFEST = loadJsonSync("./data/audio/manifest.json");

// ---------------------------------------------------------------------------
// Cultural tidbits — curated classical quotes with source citations.
// Source repository: Chinese Text Project (ctext.org)
// ---------------------------------------------------------------------------
const TIDBIT_DATA = loadJsonSync("./data/tidbit-data.json");
const CLASSICAL_TIDBITS_RAW = TIDBIT_DATA.classicalTidbitsRaw;
const TIDBIT_MAX_QUOTE_CHARS = TIDBIT_DATA.tidbitMaxQuoteChars;
const TOKEN_SYNONYMS = TIDBIT_DATA.tokenSynonyms;

Object.assign(TOKEN_SYNONYMS, {
  mr: "person",
  miss: "person",
  sir: "person",
  everyone: "person",
  child: "family",
  children: "family",
  brother: "family",
  sister: "family",
  home: "family",
  house: "family",
  live: "family",
  stay: "family",
  table: "home",
  desk: "home",
  chair: "home",
  room: "home",
  door: "home",
  gate: "home",
  clothes: "wear",
  wear: "wear",
  open: "move",
  begin: "start",
  start: "start",
  finish: "end",
  completed: "end",
  end: "end",
  wait: "time",
  maybe: "ability",
  where: "question",
  which: "question",
  what: "question",
  who: "question",
  how: "question",
  why: "question",
  this: "position",
  that: "position",
  these: "position",
  those: "position",
  noon: "time",
  yesterday: "time",
  week: "time",
  each: "time",
  every: "time",
  snow: "weather",
  class: "learn",
  lesson: "learn",
  introduce: "speak",
  welcome: "polite",
  goodbye: "polite",
  please: "polite",
  sorry: "polite",
  waiter: "polite",
  attendant: "polite",
  restaurant: "food",
  hotel: "home",
  shop: "money",
  store: "money",
  cell: "speak",
  bus: "move",
  train: "move",
  station: "move",
  airport: "move",
  airplane: "move",
  road: "move",
  return: "move",
  exit: "move",
  side: "position",
  beside: "position",
  foreign: "distance",
  from: "position",
  thing: "object",
  stuff: "object",
  matter: "object",
  cat: "animal",
  dog: "animal",
  fish: "animal",
  animal: "animal",
  flower: "plant",
  plant: "plant",
  vegetable: "food",
  tea: "drink",
  coffee: "drink",
  milk: "drink",
  cup: "drink",
  rice: "food",
  fruit: "food",
  apple: "food",
  watermelon: "food",
  egg: "food",
  dish: "food",
  cooked: "food",
  birthday: "time",
  diary: "learn",
  pencil: "learn",
  male: "person",
  female: "person",
  black: "color",
  red: "color",
  pretty: "beauty",
  beautiful: "beauty",
  most: "size",
  long: "distance",
  thin: "size",
  color: "color",
  also: "continuation",
  then: "time",
  because: "reason",
  other: "contrast",
  don: "negation",
  t: "negation",
  too: "size",
  although: "contrast",
  there: "exist",
  have: "exist",
  is: "exist",
  be: "exist",
  dance: "exercise",
  play: "exercise",
  watch: "time",
  wristwatch: "time",
  bus: "move",
  bicycle: "move",
  soccer: "exercise",
  basketball: "exercise",
  swim: "exercise",
  washing: "clean",
  wash: "clean",
  open: "move",
  close: "position",
  sit: "position",
  prepared: "prepare",
  prepare: "prepare",
  process: "time",
  ongoing: "time",
  briefly: "time",
  bit: "quantity",
  some: "quantity",
  waiting: "time",
  wait: "time",
});

function normalizeEnglishText(text) {
  return String(text || "")
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, " ")
    .replace(/\s+/g, " ")
    .trim();
}

const RAW_STOPWORDS = new Set([
  "a", "an", "the", "to", "of", "and", "or", "is", "are", "be", "in", "on", "at", "for", "with",
  "from", "it", "its", "this", "that", "these", "those",
]);
const NOISY_MEANING_TOKENS = new Set([
  "side", "form", "particle", "measure", "general", "possessive",
]);

function extractRawMeaningTokens(text) {
  const normalized = normalizeEnglishText(text);
  const tokens = new Set();
  for (const raw of normalized.split(" ")) {
    const tok = raw.trim();
    if (!tok || tok.length < 2) continue;
    if (RAW_STOPWORDS.has(tok)) continue;
    if (NOISY_MEANING_TOKENS.has(tok)) continue;
    tokens.add(tok);
  }
  return tokens;
}

function canonicalToken(token) {
  let t = token;
  if (TOKEN_SYNONYMS[t]) t = TOKEN_SYNONYMS[t];
  if (t.endsWith("ing") && t.length > 5) t = t.slice(0, -3);
  else if (t.endsWith("ed") && t.length > 4) t = t.slice(0, -2);
  else if (t.endsWith("s") && t.length > 4) t = t.slice(0, -1);
  if (TOKEN_SYNONYMS[t]) t = TOKEN_SYNONYMS[t];
  return t;
}

function extractMeaningTokens(text) {
  const normalized = normalizeEnglishText(text);
  const tokens = new Set();
  for (const raw of normalized.split(" ")) {
    const tok = canonicalToken(raw.trim());
    if (!tok || tok.length < 2) continue;
    if (NOISY_MEANING_TOKENS.has(raw.trim())) continue;
    tokens.add(tok);
  }
  return tokens;
}

function overlapCount(a, b) {
  let count = 0;
  for (const token of a) {
    if (b.has(token)) count++;
  }
  return count;
}

const ALL_TIDBIT_CARDS = [...HSK1_VOCAB, ...RADICAL_DECK_CARDS];
const CARD_MEANING_TOKENS = new Map(
  ALL_TIDBIT_CARDS.map((card) => [card.hanzi, extractMeaningTokens(card.english)])
);
const CARD_RAW_MEANING_TOKENS = new Map(
  ALL_TIDBIT_CARDS.map((card) => [card.hanzi, extractRawMeaningTokens(card.english)])
);

function normalizeHanText(text) {
  return String(text || "").replace(/\s+/g, "");
}

const TIDBIT_META = CLASSICAL_TIDBITS_RAW.map((tidbit, index) => ({
  tidbit,
  index,
  tokens: extractMeaningTokens((tidbit.relevance || []).join(" ")),
  rawTokens: extractRawMeaningTokens((tidbit.relevance || []).join(" ")),
  quoteText: normalizeHanText(tidbit.quote),
  quoteLen: normalizeHanText(tidbit.quote).length,
}));

const GENERIC_CANONICAL_TOKENS = new Set([
  "exist", "continuation", "quantity",
]);

// ---------------------------------------------------------------------------
// Audio — local MP3s generated with edge-tts (zh-CN-XiaoxiaoNeural)
// ---------------------------------------------------------------------------
function speak(hanzi) {
  const filename = AUDIO_MANIFEST[hanzi];
  if (!filename) return;
  const audio = new Audio(`./data/audio/${filename}`);
  audio.play().catch(() => {});
}

const PINYIN_TONE_CHAR_MAP = {
  "ā": ["a", 1], "á": ["a", 2], "ǎ": ["a", 3], "à": ["a", 4],
  "ē": ["e", 1], "é": ["e", 2], "ě": ["e", 3], "è": ["e", 4],
  "ī": ["i", 1], "í": ["i", 2], "ǐ": ["i", 3], "ì": ["i", 4],
  "ō": ["o", 1], "ó": ["o", 2], "ǒ": ["o", 3], "ò": ["o", 4],
  "ū": ["u", 1], "ú": ["u", 2], "ǔ": ["u", 3], "ù": ["u", 4],
  "ǖ": ["v", 1], "ǘ": ["v", 2], "ǚ": ["v", 3], "ǜ": ["v", 4],
  "ü": ["v", 5],
};

function pinyinSyllableToNumbered(syllable) {
  let tone = 5;
  let base = "";
  const text = (syllable || "").toLowerCase();

  for (const ch of text) {
    if (PINYIN_TONE_CHAR_MAP[ch]) {
      const [plain, detectedTone] = PINYIN_TONE_CHAR_MAP[ch];
      base += plain;
      if (detectedTone !== 5) tone = detectedTone;
    } else if (/[a-z]/.test(ch)) {
      base += ch;
    }
  }

  if (!base) return "";
  return `${base}${tone}`;
}

function pinyinToAudioKeys(pinyin) {
  return (pinyin || "")
    .replace(/['’]/g, " ")
    .split(/\s+/)
    .map(pinyinSyllableToNumbered)
    .filter(Boolean);
}

// Candidate pinyin-to-anchor map. Only entries that pass English-word guardrails are used.
const PHONETIC_CONFIG = loadJsonSync("./data/phonetic-config.json");
const PHONETIC_ANCHOR_CANDIDATES = PHONETIC_CONFIG.phoneticAnchorCandidates;
const ENGLISH_SOUND_ANCHOR_WORDS = new Set(PHONETIC_CONFIG.englishSoundAnchorWords);

function isEnglishAnchorWord(word) {
  return ENGLISH_SOUND_ANCHOR_WORDS.has(String(word || "").toUpperCase());
}

function canonicalizeSoundAnchorPhrase(phrase) {
  const text = String(phrase || "").trim();
  if (!text) return "";
  const body = text.replace(/^Think of\s+/i, "").replace(/[.?!]+$/, "").trim();
  if (!body) return "";
  const words = body.match(/[A-Za-z]+/g) || [];
  if (words.length === 0) return "";
  const upperWords = words.map((word) => word.toUpperCase());
  if (!upperWords.every((word) => isEnglishAnchorWord(word))) return "";
  return buildIntelligibleAnchorPhrase(upperWords);
}

function buildIntelligibleAnchorPhrase(words) {
  if (words.length === 0) return "";
  if (words.length === 1) return `Think of ${words[0]}.`;
  return `Think of ${words.join(", ")}.`;
}

function getSoundAnchor(card) {
  const keys = pinyinToAudioKeys(card.pinyin);
  if (keys.length === 0) return "";
  const parts = keys.map((key) => {
    const plain = key.replace(/[1-5]$/, "").replaceAll("v", "u");
    return String(PHONETIC_ANCHOR_CANDIDATES[plain] || "").toUpperCase();
  });
  if (parts.some((part) => !part)) return "";
  if (!parts.every((part) => isEnglishAnchorWord(part))) return "";
  return canonicalizeSoundAnchorPhrase(buildIntelligibleAnchorPhrase(parts));
}

function mergeSoundAnchorAndStory(soundAnchor, story) {
  const anchor = canonicalizeSoundAnchorPhrase(soundAnchor);
  const text = String(story || "").trim();
  if (!anchor) return text;
  if (!text) return anchor;
  const anchorWords = anchor
    .replace(/^Think of\s+/i, "")
    .replace(/[.?!]+$/, "")
    .split(/,\s*/)
    .map((word) => word.trim())
    .filter(Boolean);
  const hasAllAnchorWords = anchorWords.every((word) => {
    const escaped = word.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    return new RegExp(`(?<![A-Z\\-])${escaped}(?![A-Z\\-])`).test(text);
  });
  if (hasAllAnchorWords) return text;
  const escapedAnchor = anchor.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const anchorPattern = new RegExp(escapedAnchor, "i");
  if (anchorPattern.test(text)) return text.replace(anchorPattern, anchor);
  return `${anchor} ${text}`;
}

function normalizeMnemonicData(card) {
  const raw = card.mnemonicData;
  if (raw && typeof raw === "object") {
    const soundAnchor = canonicalizeSoundAnchorPhrase(raw.soundAnchor);
    const story = String(raw.story || "").trim();
    const components = Array.isArray(raw.components) ? raw.components : [];
    return { soundAnchor, story, components };
  }
  const parsed = parseMnemonic(card);
  return {
    soundAnchor: getSoundAnchor(card),
    story: parsed.text,
    components: parsed.chips.map((item) => ({ hanzi: item.hanzi, meaning: item.meaning })),
  };
}


// ---------------------------------------------------------------------------
// Progressive Web App setup
// ---------------------------------------------------------------------------
function initPWA() {
  const isWebProtocol = location.protocol === "https:" || location.protocol === "http:";
  if (!isWebProtocol || !("serviceWorker" in navigator)) return;

  navigator.serviceWorker.register("./sw.js").catch((err) => {
    console.error("Service worker registration failed:", err);
  });
}

// ---------------------------------------------------------------------------
// Persistence — localStorage
// ---------------------------------------------------------------------------
const LEGACY_STORAGE_KEY = "chinese-flash-cards-progress";
const DECK_STORAGE_KEYS = {
  hanzi_to_english: "hanzi_to_english_progress",
  english_to_hanzi: "english_to_hanzi_progress",
  radicals_to_english: "radicals_to_english_progress",
  sentence_to_english: "sentence_to_english_progress",
};
const ACTIVE_DECK_STORAGE_KEY = "chinese-flash-cards-active-deck";
const TIDBIT_SALT_KEY = "chinese-flash-cards-tidbit-salt";
const NEW_CARDS_PER_SESSION = 10;

const DECKS = {
  hanzi_to_english: {
    id: "hanzi_to_english",
    title: "Hanzi to English",
    subtitle: "See Hanzi, recall the English meaning.",
    cards: HSK1_VOCAB,
    mode: "hanzi_to_english",
  },
  english_to_hanzi: {
    id: "english_to_hanzi",
    title: "English to Hanzi",
    subtitle: "See English, recall the Chinese characters.",
    cards: HSK1_VOCAB,
    mode: "english_to_hanzi",
  },
  radicals_to_english: {
    id: "radicals_to_english",
    title: "Radicals to English",
    subtitle: "See radicals, recall the English meaning.",
    cards: RADICAL_DECK_CARDS,
    mode: "radicals_to_english",
  },
  sentence_to_english: {
    id: "sentence_to_english",
    title: "Sentences",
    subtitle: "See a sentence, recall the English meaning.",
    cards: SENTENCE_CARDS,
    mode: "sentence_to_english",
  },
};

function loadJson(key, fallback = {}) {
  try {
    return JSON.parse(localStorage.getItem(key)) || fallback;
  } catch {
    return fallback;
  }
}

function saveJson(key, data) {
  localStorage.setItem(key, JSON.stringify(data));
}

function getCardId(card) {
  return card.id || card.hanzi;
}

function loadDeckProgress(deckId) {
  return loadJson(DECK_STORAGE_KEYS[deckId], {});
}

function saveDeckProgress(deckId, data) {
  saveJson(DECK_STORAGE_KEYS[deckId], data);
}

function migrateLegacyProgress() {
  const legacy = loadJson(LEGACY_STORAGE_KEY, null);
  if (!legacy || typeof legacy !== "object") return;
  const existing = loadDeckProgress("hanzi_to_english");
  if (Object.keys(existing).length === 0) {
    saveDeckProgress("hanzi_to_english", legacy);
  }
}

function getSavedActiveDeckId() {
  const saved = localStorage.getItem(ACTIVE_DECK_STORAGE_KEY);
  return DECKS[saved] ? saved : null;
}

function saveActiveDeckId(deckId) {
  localStorage.setItem(ACTIVE_DECK_STORAGE_KEY, deckId);
}

function getDailyTidbitSalt() {
  const today = todayStr();
  try {
    const saved = JSON.parse(localStorage.getItem(TIDBIT_SALT_KEY) || "null");
    if (saved && saved.date === today && Number.isFinite(saved.salt)) {
      return saved.salt;
    }
    const salt = Math.floor(Math.random() * 1_000_000_000);
    localStorage.setItem(TIDBIT_SALT_KEY, JSON.stringify({ date: today, salt }));
    return salt;
  } catch {
    return 0;
  }
}

// ---------------------------------------------------------------------------
// Spaced repetition — simplified SM-2
// ---------------------------------------------------------------------------
function todayStr() {
  return new Date().toISOString().slice(0, 10);
}

function shuffle(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function escapeHtml(text) {
  return String(text || "")
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#39;");
}

function hashString(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = (hash * 31 + str.charCodeAt(i)) >>> 0;
  }
  return hash;
}

function getCulturalTidbitForCard(card) {
  const key = card.hanzi || "";
  const seed = hashString(`${key}|${todayStr()}|${getDailyTidbitSalt()}`);
  const cardTokens = CARD_MEANING_TOKENS.get(key) || new Set();
  const cardRawTokens = CARD_RAW_MEANING_TOKENS.get(key) || new Set();
  if (cardTokens.size === 0 && cardRawTokens.size === 0) return null;

  const scored = [];
  for (const meta of TIDBIT_META) {
    if (meta.quoteLen > TIDBIT_MAX_QUOTE_CHARS) continue;
    const canonicalScore = overlapCount(cardTokens, meta.tokens);
    const rawScore = overlapCount(cardRawTokens, meta.rawTokens);
    const canonicalSpecificScore = [...cardTokens].reduce(
      (n, token) => n + (!GENERIC_CANONICAL_TOKENS.has(token) && meta.tokens.has(token) ? 1 : 0),
      0
    );
    // Require direct lexical overlap, or at least one non-generic conceptual overlap.
    if (rawScore === 0 && canonicalSpecificScore === 0) continue;
    const score = rawScore * 3 + canonicalSpecificScore * 2 + canonicalScore;
    scored.push({ ...meta, score, rawScore, canonicalScore, canonicalSpecificScore });
  }
  if (scored.length === 0) return null;

  scored.sort((a, b) => {
    if (b.score !== a.score) return b.score - a.score;
    if (a.quoteLen !== b.quoteLen) return a.quoteLen - b.quoteLen;
    return a.index - b.index;
  });
  const topScore = scored[0].score;
  // Keep a small pool of strong candidates to reduce repetition.
  const best = scored.filter((item) => item.score >= topScore - 1).slice(0, 6);
  return best[seed % best.length].tidbit;
}

function getTidbitAttribution(tidbit) {
  const source = tidbit.source || "";
  if (source.includes("道德经")) return "Laozi, Tao Te Ching";
  if (source.includes("孙子兵法") || source.includes("孙子")) return "Sun Tzu, The Art of War";
  if (source.includes("论语")) return "Confucius, Analects";
  return source || "Classical Chinese text";
}

function buildQueue(cards, progress) {
  const today = todayStr();
  const due = [];
  const unseen = [];

  for (const card of cards) {
    const id = getCardId(card);
    const p = progress[id];
    if (!p) unseen.push(card);
    else if (p.due <= today) due.push(card);
  }

  const baseQueue = [...shuffle(due), ...shuffle(unseen).slice(0, NEW_CARDS_PER_SESSION)];
  if (baseQueue.length === 0) return baseQueue;
  return baseQueue;
}

function rateCard(card, progress, difficulty, deckId) {
  const id = getCardId(card);
  const p = progress[id] || { interval: 0, ease: 2.5, repetitions: 0 };
  let { interval, ease, repetitions } = p;

  if (difficulty === "hard") {
    interval = 1;
    ease = Math.max(1.3, ease - 0.2);
    repetitions = 0;
  } else if (difficulty === "medium") {
    if (repetitions === 0) interval = 1;
    else if (repetitions === 1) interval = 6;
    else interval = Math.round(interval * ease);
    repetitions++;
  } else if (difficulty === "easy") {
    if (repetitions === 0) interval = 4;
    else interval = Math.round(interval * ease * 1.3);
    ease = Math.min(3.0, ease + 0.15);
    repetitions++;
  }

  const due = new Date();
  due.setDate(due.getDate() + interval);

  progress[id] = {
    interval,
    ease,
    repetitions,
    due: due.toISOString().slice(0, 10),
  };

  saveDeckProgress(deckId, progress);
}

// ---------------------------------------------------------------------------
// UI
// ---------------------------------------------------------------------------
const app = document.getElementById("app");
const progressEl = document.getElementById("progress");
const resetBtn = document.getElementById("reset-btn");
const RADICAL_MEANINGS = Object.fromEntries(
  RADICAL_DECK_CARDS.map((card) => [card.hanzi, card.english])
);
const RADICAL_SIDE_FORM_FULL_FORM = {
  "讠": "言",
  "氵": "水",
  "扌": "手",
  "忄": "心",
  "亻": "人",
  "钅": "金",
  "纟": "糸",
  "阝": "阜",
};
const RADICAL_SIDE_FORM_SHIFT = {
  "讠": "0.12em",
  "氵": "0.1em",
  "扌": "0.1em",
  "忄": "0.1em",
  "亻": "0.1em",
  "钅": "0.1em",
  "纟": "0.1em",
  "阝": "0.16em",
};

let activeDeckId = null;
let progress = {};
let queue = [];
let lessonQueue = [...queue];
let currentIndex = 0;
let stage = 0;

function getActiveDeck() {
  return activeDeckId ? DECKS[activeDeckId] : null;
}

function setActiveDeck(deckId) {
  activeDeckId = deckId;
  saveActiveDeckId(deckId);
  progress = loadDeckProgress(deckId);
  startNewLessonFromProgress();
}

function getRadicalSideFormFullForm(deck, card) {
  if (deck.mode !== "radicals_to_english") return "";
  return RADICAL_SIDE_FORM_FULL_FORM[card.hanzi] || "";
}

function getRadicalSideFormShift(deck, card) {
  if (deck.mode !== "radicals_to_english") return "";
  return RADICAL_SIDE_FORM_SHIFT[card.hanzi] || "";
}

function startNewLessonFromProgress() {
  const deck = getActiveDeck();
  queue = deck ? buildQueue(deck.cards, progress) : [];
  lessonQueue = [...queue];
  currentIndex = 0;
}

function replayLesson() {
  if (lessonQueue.length === 0) return;
  queue = shuffle(lessonQueue);
  currentIndex = 0;
  renderStudyDeck();
}

function parseRoute() {
  const raw = location.hash.replace(/^#\/?/, "");
  if (!raw) return { route: "decks", params: new URLSearchParams() };
  const [path, query = ""] = raw.split("?");
  const route = ["decks", "study"].includes(path) ? path : "decks";
  return { route, params: new URLSearchParams(query) };
}

function parseMnemonic(card) {
  const mnemonic = card.mnemonic || "";
  const componentPattern = /([\u3400-\u9fff]+)\s*\(([^)]+)\)/g;
  const chips = [];
  const seen = new Set();

  for (const match of mnemonic.matchAll(componentPattern)) {
    const hanzi = match[1].trim();
    const meaning = match[2].trim();
    const key = `${hanzi}|${meaning}`;
    if (!hanzi || !meaning || seen.has(key)) continue;
    seen.add(key);
    chips.push({ hanzi, meaning });
  }

  let text = mnemonic.trim();
  const firstStop = text.search(/[。.!?]/);
  if (firstStop !== -1) {
    const head = text.slice(0, firstStop + 1);
    if (/[\u3400-\u9fff]+\s*\([^)]+\)/.test(head)) {
      text = text.slice(firstStop + 1).trim();
    }
  }

  if (!text) {
    text = mnemonic
      .replace(componentPattern, "$1")
      .replace(/\s*[+＋=＝]\s*/g, " ")
      .replace(/\s+/g, " ")
      .trim();
  }

  // Mnemonic line should be English-only; keep Hanzi in chips above.
  text = text
    .replace(/[\u3400-\u9fff]+/g, " ")
    .replace(/\([^)]*\)/g, " ")
    .replace(/\s*[+＋=＝]\s*/g, " ")
    .replace(/\s*[-–—]\s*/g, " — ")
    .replace(/^[^a-zA-Z0-9]+/, "")
    .replace(/\s+/g, " ")
    .trim();

  // Keep mnemonic concise: max two short sentences.
  const sentenceParts = text.match(/[^.!?]+[.!?]?/g) || [];
  if (sentenceParts.length > 2) {
    text = sentenceParts.slice(0, 2).join(" ").trim();
  }

  return { text, chips };
}

function buildMnemonicAndChips(card, options = {}) {
  const includeSoundAnchor = options.includeSoundAnchor !== false;
  const includeChips = options.includeChips !== false;
  const mnemonicData = normalizeMnemonicData(card);
  const chips = [];
  const seen = new Set();
  const pushChip = (hanzi, meaning) => {
    const h = (hanzi || "").trim();
    const m = (meaning || "").trim();
    if (!h || !m) return;
    const key = `${h}|${m}`;
    if (seen.has(key)) return;
    seen.add(key);
    chips.push({ hanzi: h, meaning: m });
  };

  for (const item of mnemonicData.components) {
    pushChip(item.hanzi, item.meaning);
  }

  if (includeChips) {
    const parsed = parseMnemonic(card);
    for (const item of parsed.chips) {
      pushChip(item.hanzi, item.meaning);
    }

    const equalPattern = /([\u3400-\u9fff]+)\s*=\s*([^。.!?;；]+)/g;
    for (const match of (card.mnemonic || "").matchAll(equalPattern)) {
      const token = match[1].trim();
      const meaning = match[2].trim();
      if (!token || !meaning) continue;
      for (const ch of token) {
        pushChip(ch, meaning);
      }
    }

    for (const ch of card.hanzi) {
      const covered = chips.some((item) => item.hanzi.includes(ch));
      if (covered) continue;
      const meaning = RADICAL_MEANINGS[ch] || "word component";
      pushChip(ch, meaning);
    }
    if (chips.length === 0) pushChip(card.hanzi, "word component");
  }
  if (includeChips) {
    // Avoid self-referential chips (notably radical cards like 木 -> "木 wood/tree").
    const filtered = chips.filter((item) => item.hanzi !== card.hanzi);
    chips.length = 0;
    chips.push(...filtered);
  }

  const story = String(mnemonicData.story || "");
  const text = includeSoundAnchor
    ? mergeSoundAnchorAndStory(mnemonicData.soundAnchor, story)
    : story.trim();
  return { text, chips };
}

function getDeckDueCount(deck) {
  const today = todayStr();
  const deckProgress = loadDeckProgress(deck.id);
  let count = 0;
  for (const card of deck.cards) {
    const p = deckProgress[getCardId(card)];
    if (!p || p.due <= today) count++;
  }
  return count;
}

function renderDeckSelection() {
  progressEl.textContent = "Choose a deck";
  let html = '<section class="study-page">';

  for (const deck of Object.values(DECKS)) {
    const dueCount = getDeckDueCount(deck);
    html += '<div style="margin:10px 0;">';
    html += `<a class="chip-link" style="display:block;padding:12px 14px;" href="#/study?deck=${deck.id}">`;
    html += `<strong>${escapeHtml(deck.title)}</strong><br>`;
    html += `<small>${escapeHtml(deck.subtitle)} · ${dueCount} due/new</small>`;
    html += "</a>";
    html += "</div>";
  }

  html += "</section>";
  app.innerHTML = html;
}

function renderSentenceCard(deck, card) {
  stage = 0;
  render();

  function render() {
    const finalStage = 2;
    let html = '<div class="card" id="flashcard">';

    html += `<div class="sentence-hanzi">${escapeHtml(card.hanzi)}</div>`;

    if (stage >= 1) {
      html += `<div class="sentence-pinyin">${escapeHtml(card.pinyin)}</div>`;
      html += '<button class="speaker-btn" id="speak-btn" title="Play pronunciation">&#128264;</button>';
    }

    if (stage >= finalStage) {
      html += `<div class="sentence-english">${escapeHtml(card.english)}</div>`;

      const vocabWords = card.vocabWords || [];
      if (vocabWords.length > 0) {
        html += '<div class="word-gloss-chips">';
        for (const word of vocabWords) {
          html += '<span class="word-gloss-chip">';
          html += `<span class="chip-hanzi">${escapeHtml(word.hanzi)}</span>`;
          html += ` ${escapeHtml(word.english)}`;
          html += "</span>";
        }
        html += "</div>";
      }
    }

    if (stage >= finalStage) {
      html += '<div class="difficulty-buttons">';
      html += '<button class="btn-easy" data-difficulty="easy">Easy</button>';
      html += '<button class="btn-medium" data-difficulty="medium">Medium</button>';
      html += '<button class="btn-hard" data-difficulty="hard">Hard</button>';
      html += "</div>";
      html += '<button class="reset-btn reset-card-btn" id="reset-card-btn">Reset card</button>';
    }

    if (stage < finalStage) {
      const hints = ["tap to reveal pinyin", "tap to reveal translation"];
      html += `<div class="hint">${hints[stage]}</div>`;
    }

    html += '<div class="deck-back-link"><a href="#/decks">Back to deck selection</a></div>';
    html += "</div>";
    app.innerHTML = html;

    if (stage < finalStage) {
      document.getElementById("flashcard").addEventListener("click", () => {
        stage++;
        render();
      });
    }

    const speakBtn = document.getElementById("speak-btn");
    if (speakBtn) {
      speakBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        speak(card.hanzi);
      });
    }

    for (const btn of app.querySelectorAll(".difficulty-buttons button")) {
      btn.addEventListener("click", (e) => {
        e.stopPropagation();
        rateCard(card, progress, btn.dataset.difficulty, deck.id);
        currentIndex++;
        renderStudyDeck();
      });
    }

    const resetCardBtn = document.getElementById("reset-card-btn");
    if (resetCardBtn) {
      resetCardBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        stage = 0;
        render();
      });
    }
  }
}

function renderStudyDeck() {
  const deck = getActiveDeck();
  if (!deck) {
    renderDeckSelection();
    return;
  }

  if (currentIndex >= queue.length) {
    progressEl.textContent = "";
    let html =
      '<div class="done"><div class="emoji">&#127881;</div>' +
      "All done for today!<br>" +
      '<small style="color:#aaa">Come back tomorrow for more review.</small>';
    html += '<div style="margin-top:14px;"><a class="reset-btn" href="#/decks">Deck selection</a></div>';
    if (lessonQueue.length > 0) {
      html += '<div style="margin-top:14px;"><button class="reset-btn" id="replay-lesson-btn">Replay lesson</button></div>';
    }
    html += "</div>";
    app.innerHTML = html;
    const replayBtn = document.getElementById("replay-lesson-btn");
    if (replayBtn) {
      replayBtn.addEventListener("click", replayLesson);
    }
    return;
  }

  const card = queue[currentIndex];

  progressEl.textContent = `${deck.title} · Card ${currentIndex + 1} of ${queue.length}`;
  stage = 0;

  if (deck.mode === "sentence_to_english") {
    renderSentenceCard(deck, card);
    return;
  }

  render();

  function render() {
    const isEnglishToHanzi = deck.mode === "english_to_hanzi";
    const finalStage = 2;
    const sideFormFullForm = getRadicalSideFormFullForm(deck, card);
    const sideFormShift = getRadicalSideFormShift(deck, card);
    let html = '<div class="card" id="flashcard">';
    const parsedMnemonic = stage >= finalStage ? buildMnemonicAndChips(card) : null;
    const tidbit = stage >= finalStage ? getCulturalTidbitForCard(card) : null;

    if (isEnglishToHanzi) {
      html += `<div class="english">${card.english}</div>`;
    } else {
      if (sideFormShift) {
        html += `<div class="hanzi"><span class="radical-side-glyph" style="--side-shift:${escapeHtml(sideFormShift)}">${escapeHtml(card.hanzi)}</span></div>`;
      } else {
        html += `<div class="hanzi">${escapeHtml(card.hanzi)}</div>`;
      }
      if (sideFormFullForm) {
        html += `<div class="radical-side-note">side form of ${escapeHtml(sideFormFullForm)}</div>`;
      }
    }

    if (stage >= 1) {
      html += `<div class="pinyin">${card.pinyin}</div>`;
      html += '<button class="speaker-btn" id="speak-btn" title="Play pronunciation">&#128264;</button>';
    }

    if (stage >= finalStage) {
      if (isEnglishToHanzi) {
        html += `<div class="hanzi">${card.hanzi}</div>`;
      } else {
        html += `<div class="english">${card.english}</div>`;
      }
      if (parsedMnemonic.text) {
        html += `<div class="mnemonic">${escapeHtml(parsedMnemonic.text)}</div>`;
      }
      if (parsedMnemonic.chips.length > 0) {
        html += '<div class="related-radicals">';
        for (const item of parsedMnemonic.chips) {
          html += `<span class="chip-link">${escapeHtml(item.hanzi)} ${escapeHtml(item.meaning)}</span>`;
        }
        html += "</div>";
      }
      if (tidbit) {
        html += '<div class="cultural-tidbit">';
        html += `<div class="cultural-quote">${escapeHtml(tidbit.quote)}</div>`;
        if (tidbit.translation) {
          html += `<div class="cultural-translation">${escapeHtml(tidbit.translation)}</div>`;
        }
        const attribution = getTidbitAttribution(tidbit);
        html += '<div class="cultural-source">';
        html += `&mdash; ${escapeHtml(attribution)}`;
        if (tidbit.source && tidbit.source !== attribution) {
          html += ` · ${escapeHtml(tidbit.source)}`;
        }
        html += ` · <a href="${escapeHtml(tidbit.url)}" target="_blank" rel="noopener noreferrer">source</a>`;
        html += "</div>";
        html += "</div>";
      }
    }

    if (stage >= finalStage) {
      html += '<div class="difficulty-buttons">';
      html += '<button class="btn-easy" data-difficulty="easy">Easy</button>';
      html += '<button class="btn-medium" data-difficulty="medium">Medium</button>';
      html += '<button class="btn-hard" data-difficulty="hard">Hard</button>';
      html += "</div>";
      html += '<button class="reset-btn reset-card-btn" id="reset-card-btn">Reset card</button>';
    }

    if (stage < finalStage) {
      const hints = ["tap to reveal pinyin", "tap to reveal full answer"];
      html += `<div class="hint">${hints[stage]}</div>`;
    }

    html += '<div class="deck-back-link"><a href="#/decks">Back to deck selection</a></div>';
    html += "</div>";
    app.innerHTML = html;

    // Card click advances stage (only before answer is revealed)
    if (stage < finalStage) {
      document.getElementById("flashcard").addEventListener("click", () => {
        stage++;
        render();
      });
    }

    // Speaker button plays audio without advancing
    const speakBtn = document.getElementById("speak-btn");
    if (speakBtn) {
      speakBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        speak(card.hanzi);
      });
    }

    // Difficulty buttons rate and advance to next card
    for (const btn of app.querySelectorAll(".difficulty-buttons button")) {
      btn.addEventListener("click", (e) => {
        e.stopPropagation();
        rateCard(card, progress, btn.dataset.difficulty, deck.id);
        currentIndex++;
        renderStudyDeck();
      });
    }

    const resetCardBtn = document.getElementById("reset-card-btn");
    if (resetCardBtn) {
      resetCardBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        stage = 0;
        render();
      });
    }
  }
}

function renderRoute() {
  const { route, params } = parseRoute();
  resetBtn.style.display = route === "study" ? "inline-block" : "none";

  if (route === "decks") {
    renderDeckSelection();
    return;
  }

  const requestedDeckId = params.get("deck") || activeDeckId || getSavedActiveDeckId();
  if (!requestedDeckId || !DECKS[requestedDeckId]) {
    location.hash = "#/decks";
    return;
  }
  if (activeDeckId !== requestedDeckId) setActiveDeck(requestedDeckId);
  renderStudyDeck();
}

resetBtn.addEventListener("click", () => {
  const deck = getActiveDeck();
  if (!deck) return;
  if (confirm(`Reset progress for "${deck.title}"? This cannot be undone.`)) {
    localStorage.removeItem(DECK_STORAGE_KEYS[deck.id]);
    progress = {};
    startNewLessonFromProgress();
    renderRoute();
  }
});

window.addEventListener("hashchange", renderRoute);
migrateLegacyProgress();
if (!location.hash) location.hash = "#/decks";
renderRoute();
initPWA();
</script>
</body>
</html>
